<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LiamCoding</title>
    <description>Hello! I'm Liam 👋I'm a developer working at ./-</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 24 Dec 2022 12:47:15 +0900</pubDate>
    <lastBuildDate>Sat, 24 Dec 2022 12:47:15 +0900</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>What is Apache Kafka?</title>
        <description>&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-intro&quot;&gt;💡 Intro&lt;/h2&gt;

&lt;p&gt;Kafka는 많은 서비스에서 백엔드로 사용하고 있습니다. 저는 Kafka의 ‘K’ 정도만 알고 있기 때문에, 오늘은 Kafka의 개념과 기본 구조에 대해서 알아보려고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-kafka의-탄생&quot;&gt;🔎 Kafka의 탄생&lt;/h2&gt;

&lt;p&gt;링크드인은 사이트가 급속도로 성장하면서 기존의 End to End 연결 방식이었던 아키텍처로는 복잡도, 데이터 파이프라인 관리 등의 어려움 때문에 새로운 아키텍처가 필요로 해졌습니다. 
이를 해결하기 위해 링크드인은 Kafka라는 메시징 분산 스트리밍 플랫폼을 개발하게 되었습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;당시 링크드인의 요구사항은 1.높은 처리량으로 데이터를 실시간으로 처리 가능 해야 하며, 2.메시지의 영속성을 보장해 주고, 3.Scale out이 용이 해야 한다 등이 있었습니다.
하지만 당시의 제품들은 높은 처리량이 우선 순위였던 링크드인의 요구사항보다 트랜젝션의 관리가 너무 오버스펙이거나, 메시지 큐로 데이터를 쌓긴 하지만 장시간 쌓이는 것은 고려하지 않는 등의 문제로 충족시키지 못했습니다.
당시 링크드인의 자세한 요구사항은 🌎&lt;a href=&quot;https://www.hanbit.co.kr/media/channel/view.html?cms_code=CMS9400468504&quot;&gt;한빛미디어-링크드인은 왜 카프카를 만들었나&lt;/a&gt;을 통해 확인 하실 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;what-is-apache-kafka&quot;&gt;What is Apache Kafka?&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Apache Kafka is an open-source distributed event streaming platform used by thousands of companies for high-performance data pipelines, 
streaming analytics, data integration, and mission-critical applications.&lt;/code&gt; &lt;span style=&quot;color:gray; font-size:2px;&quot;&gt;- 출처: Apache Kafka&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Apache Kafka의 공식사이트에서는 Apache Kafka란 수천 개의 기업이 고성능 데이터 파이프라인, 스트리밍 분석, 데이터 통합, 미션 크리티컬 애플리케이션을 위해 사용하는 오픈 소스 분산 이벤트 스트리밍 플랫폼이라고 설명합니다.
즉, Kafka는 데이터를 생성하는 어플리케이션과 데이터를 소비하는 어플리케이션 간의 중재자 역할을 함으로써 데이터의 전송 제어, 처리, 관리 역할을 하며 Publish-Subscribe 모델을 구현한 분산 메시징 시스템입니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Message Queue란? 프로그램 간 데이터를 교환할 때 사용하는 통신 방법 중 하나이며 🌎&lt;a href=&quot;https://tecoble.techcourse.co.kr/post/2021-07-03-message-oriented-middleware/&quot;&gt;Message-Oriented Middleware&lt;/a&gt;의 구현을 의미합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;apache-kafka의-특징&quot;&gt;Apache Kafka의 특징&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Kafka의 topic에 여러 프로듀서가 동시에 메시지를 전송할 수 있으며, Kafka topic의 메시지를 여러 컨슈머들이 동시에 읽어 갈 수 있습니다. 
때문에, 다중 프로듀서/컨슈머의 지원으로 하나의 Kafka 시스템을 통해 다양한 애플리케이션이 데이터를 주고 받을 수 있습니다.&lt;/li&gt;
  &lt;li&gt;Kafka는 프로듀서가 생성한 메시지를 브로커가 위치한 서버의 파일 시스템에 저장할 수 있기 때문에, 데이터의 영속성을 보장해 줍니다.&lt;/li&gt;
  &lt;li&gt;Scale out 즉, 확장성이 용이합니다. 프로듀서, 컨슈머, 브로커등을 운영중에 추가할 수 있으며 예를 들어 초창기에 적은 수의 브로커들로 클러스터를 운영하다가 
시스템 트래픽이 높아지면 브로커를 추가해서 클러스터를 확장할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;Kafka는 Push가 아닌 컨슈머가 브로커에게서 메시지를 가져오는 Pull방식이기 때문에 컨슈머의 처리량을 브로커가 고민할 필요가 없습니다. 
즉, 컨슈머는 자신이 처리할 수 있는 만큼의 메시지만 브로커에게서 가져가면 되기 때문에 최적의 메시지처리 성능을 가질 수 있습니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;apache-kafka의-아키텍처&quot;&gt;Apache Kafka의 아키텍처&lt;/h3&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kafka/kafka_architecture.png&quot; alt=&quot;Kafka Architecture&quot; /&gt;&lt;em&gt;이미지 1. Kafka 아키텍처(출처: Developer.holee Blog)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Kafka는 Publish-Subscribe 모델을 기반으로 동작하며, 위 이미와 같이 크게 &lt;strong&gt;producer, consumer, broker, Zookeeper&lt;/strong&gt;로 구성됩니다. Producer는 특정 topic의 메시지를 생성한 뒤 해당 메시지를 broker에 전달합니다.
Broker가 전달받은 메시지를 topic별로(Foo, bar) 분류하여 쌓아놓으면, 해당 topic을 구독하는 consumer들이 메시지를 가져가서 처리합니다. 클러스터 내의 broker에 대한 분산 처리는 &lt;strong&gt;이미지 1. Kafka 아키텍처&lt;/strong&gt;와 같이 🌎&lt;a href=&quot;https://zookeeper.apache.org/&quot;&gt;Apache ZooKeeper&lt;/a&gt;가 담당합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;여담으로, Apache Kafka에 대한 자료를 찾다가 Apache Kafka에서 Zookeeper을 제거한다는 소식이 있다는 것을 알게되었습니다. 🌎&lt;a href=&quot;https://www.itworld.co.kr/news/235784&quot;&gt;아파치 카프카에서 ‘주키퍼’ 빠진다…”내부 메타데이터 프로토콜로 대체”&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;조금 더 깊이 들어 가기 전, Apache Kafka의 기본 개념은 아래와 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;span style=&quot;background-color:#f7ddbe&quot;&gt;프로듀서(Producer)&lt;/span&gt; : 데이터를 발생시키고 Kafka 클러스터에 적재하는 프로세스입니다.&lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;background-color:#f7ddbe&quot;&gt;카프카 클러스터(Kafka Cluster)&lt;/span&gt; : 카프카 클러스터는 카프카 서버로 이루어진 클러스터를 말하며, 카프카 클러스터를 이루는 각 요소는 다음과 같습니다.&lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;background-color:#f7ddbe&quot;&gt;토픽(Topic)&lt;/span&gt; : Kafka 클러스터에 데이터를 관리할 시 그 기준이 되는 개념입니다. 토픽은 Kafka 클러스터에서 여러개 만들 수 있으며 하나의 토픽은 1개 이상의 파티션으로 구성되어 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;background-color:#f7ddbe&quot;&gt;브로커(Broker)&lt;/span&gt; : Broker는 실행 된 Kafka serve 중 1대를 뜻합니다.&lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;background-color:#f7ddbe&quot;&gt;파티션(Partition)&lt;/span&gt; : 각 토픽 당 데이터를 분산 처리하는 단위입니다. Kafka에서는 토픽 안에 파티션을 나누어 그 수 대로 데이터를 분산처리합니다.&lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;background-color:#f7ddbe&quot;&gt;Offset&lt;/span&gt; : 파티션 내의 각 레코드를 고유하게 식별하는 순차적인 ID를 뜻합니다.&lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;background-color:#f7ddbe&quot;&gt;주키퍼(Zookeeper)&lt;/span&gt; : 주키퍼는 분산 코디네이션 시스템입니다. Kafka 브로커를 하나의 클러스터로 코디네이팅하는 역할을 합니다.&lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;background-color:#f7ddbe&quot;&gt;컨슈머 그룹(Consumer Group)&lt;/span&gt; : 컨슈머의 집합을 구성하는 단위입니다. 카프카에서는 컨슈머 그룹으로서 데이터를 처리하며 컨슈머 그룹 안의 컨슈머 수만큼 파티션의 데이터를 분산처리하게 됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;background-color:#f7ddbe&quot;&gt;Broker Partition Replication&lt;/span&gt; : Replication은 각 Topic의 Partition들을 Kafka Cluster내의 다른 Broker들로 복제하는 것을 말하며 Topic생성 시 Replication의 수를 지정할 수 있습니다. 생성된 Replication은 Leader와 Follower로 나뉘어 ISR(In Sync Replica)이라는 일종의 Replication Group을 형성하여 관리됩니다.&lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;background-color:#f7ddbe&quot;&gt;ISR(In Sync Replica)&lt;/span&gt; : Reader, Follower 파티션이 모두 동기화된 상태를 말합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;kafka-아키텍처의-구성요소&quot;&gt;Kafka 아키텍처의 구성요소&lt;/h3&gt;

&lt;h4 id=&quot;1-topic과-partition&quot;&gt;1. &lt;span style=&quot;background-color:#fff5b1&quot;&gt;Topic&lt;/span&gt;과 &lt;span style=&quot;background-color:#fff5b1&quot;&gt;Partition&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kafka/topic.png&quot; alt=&quot;Topic&quot; /&gt;&lt;em&gt;이미지 2. Kafka Topic(출처: Apache Kafka)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;하나의 topic이 3개의 partition에 분산되어 순차적으로 저장되어지는데, 이 때 각 partition은 0부터 1씩 증가하는 offset 값(고유 ID)을 메시지에 부여합니다.
offset 값은 partition마다 별도로 관리되기 때문에 topic내에서 메시지를 식별할 때는 partition 번호와 offset 값을 함께 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-broker&quot;&gt;2. &lt;span style=&quot;background-color:#fff5b1&quot;&gt;Broker&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Kafka Cluster는 여러대의 broker(server)로 구성되어져 있습니다. 보통 3개 이상의 broker로 클러스터를 운영하며, 각각의 broker는 고유한 id 값으로 구분되어집니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kafka/Replication.png&quot; alt=&quot;Replication&quot; /&gt;&lt;em&gt;이미지 3. Replication(파란색이 리더)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;background-color:#f7ddbe&quot;&gt;Replication&lt;/span&gt;은 클러스터로 묶인 브로커 중 일부에 장애가 발생하더라도 데이터를 유실하지 않고 안전 하게 하기 위해 사용됩니다.
Kafka의 데이터 복제는 파티션 단위로 이루어집니다. 위와 같이 3개의 broker가 있을 때, 복제된 파티션은 &lt;strong&gt;1개의 리더(leader)&lt;/strong&gt;와 &lt;strong&gt;N-1개의 팔로워(follower)&lt;/strong&gt;로 구성됩니다.
각각의 팔로워는 리더의 오프셋을 확인하고, 현재 자신이 가지고 있는 오프셋과 차이가 나는 경우 리더로부터 데이터를 가져와서 자신의 파티션에 저장합니다. 파티션의 데이터가 복제되므로 복제 개수만큼의
비용이 발생하게 되지만 데이터의 안전이 보장되기 때문에 이러한 비용을 감수하고 복제를 수행한다고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kafka/Replication-error.png&quot; alt=&quot;Replication-error&quot; /&gt;&lt;em&gt;이미지 4. Replication-error&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;여기서 갑자기 리더의 broker에 error가 발생하게 된다면, 팔로워 파티션 중 하나가 리더 파티션의 지위를 넘겨받게 됩니다. 
이를 통해 데이터가 유실되지 않고 데이터의 안전성을 보장할 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-consumers와-consumer-groups&quot;&gt;3. &lt;span style=&quot;background-color:#fff5b1&quot;&gt;Consumers&lt;/span&gt;와 &lt;span style=&quot;background-color:#fff5b1&quot;&gt;Consumer Groups&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kafka/consumer-groups.png&quot; alt=&quot;Consumer Groups&quot; /&gt;&lt;em&gt;이미지 5. Consumer Groups&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Kafka의 파티션은 consumer group당 오로지 하나의 컨슈머의 접근만을 허용합니다. 따라서 동일한 consumer group에 속하는 컨슈머끼리는 동일한 파티션에 접근할 수 없습니다.
만일, 컨슈머가 추가/제거되면 추가/제거된 컨슈머가 속한 consumer group 내의 컨슈머들의 파티션 재분배가 발생하고, broker가 추가/제거되면 전체 consumer group에서 파티션 재분배가 발생합니다.&lt;/p&gt;

&lt;p&gt;위의 그림과 같이 consumer group을 구성하는 컨슈머의 수가 파티션의 수보다 작으면 하나의 컨슈머가 여러 개의 파티션을 소유할 수 있습니다. 
하지만, 반대로 컨슈머의 수가 파티션의 수보다 많다면 몇몇 컨슈머는 수행 하는 것이 없이 놀고 있을 수 있습니다. 때문에 파티션 개수와 컨슈머 수의 적절한 설정이 필요합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;끝맺음&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Apache Kafka는 근래에 가졌던 가장 최고의 관심사 였는데, 오늘 공부를 해보면서 이론만으로는 부족하다는 느낌을 절실히 경험했습니다. 
다음 포스팅에는 이론이 아닌 실전편의 Kafka를 포스팅 해보려고 합니다! 공부하면서 포스팅을 하다보니 많은 부족한 점이 있을 수 있습니다. 
혹여나 내용에 이상이 있다면 댓글로 알려주시면 감사드립니다! 😀👍&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[참고자료]&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://kafka.apache.org/081/documentation.html&quot;&gt;Apache Kafka Docs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://devfunny.tistory.com/823&quot;&gt;서해바다 - Apache Kafka 기본 개념 총정리&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://tecoble.techcourse.co.kr/post/2021-07-03-message-oriented-middleware/&quot;&gt;Message Oriented Middleware&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.hanbit.co.kr/media/channel/view.html?cms_code=CMS9400468504&quot;&gt;링크드인은 왜 Kafka를 만들었나&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://velog.io/@king3456/Apache-Kafka-%EA%B8%B0%EB%B3%B8%EA%B0%9C%EB%85%90&quot;&gt;Developer.holee - Apache Kafka&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zookeeper.apache.org/&quot;&gt;https://zookeeper.apache.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 10 Dec 2022 17:05:22 +0900</pubDate>
        <link>http://localhost:4000/kafka/</link>
        <guid isPermaLink="true">http://localhost:4000/kafka/</guid>
        
        
        <category>Kafka</category>
        
      </item>
    
      <item>
        <title>My Diary</title>
        <description>&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-대충-다이어리용-끄적임&quot;&gt;🔮 대충 다이어리용 끄적임&lt;/h2&gt;

&lt;h3 id=&quot;-2022-09-25-155520&quot;&gt;🗓 2022-09-25 15:55:20&lt;/h3&gt;

&lt;p&gt;커뮤니티에서 &lt;strong&gt;&lt;a href=&quot;http://www.yes24.com/Product/Goods/93997435?pid=123487&amp;amp;cosemkid=go16033550339966347&amp;amp;gclid=Cj0KCQjw1bqZBhDXARIsANTjCPJp7r0vo4GmU6npFF04iJT11yK1sOUduYI0opq8lfSdFa49gdKnO-waAkxXEALw_wcB&quot;&gt;IT 엔지니어를 위한 네트워크 입문&lt;/a&gt;&lt;/strong&gt; 이라는 네트워크에 대한 책을 추천을 받았습니다. 사알짝 늦은 감이 있나 싶었지만, 제가 보기에 저는 아직 네트워크에 네ㅌ… 정도(?)만을 아는 것 같기도 하고 다시 기초를 탄탄히 다져보면 좋을 것 같은 생각에 곧바로 구매했습니다. 이틀 전에 구매를 하고 오늘 오전에 받아서  오늘부터 정독해 보려고 합니다.(지금 하고 있는 것들이 너무 많아서 조금씩이라도 꾸준히 정독하려고 합니다.🥲)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/diary/2022-09-25-book.jpeg&quot; alt=&quot;IT 엔지니어를 위한 네트워크 입문&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-2022-09-28-135533&quot;&gt;🗓 2022-09-28 13:55:33&lt;/h3&gt;

&lt;p&gt;서점을 돌아다니던 도중,,,, &lt;strong&gt;&lt;a href=&quot;http://www.yes24.com/Product/Goods/110726524&quot;&gt;클라우드 AWS 자격증으로 시작하기&lt;/a&gt;&lt;/strong&gt; 라는 책을 봤습니다. 대충 내용을 훑어보니, AWS Cloud Practitioner 자격증과 AWS Solutions Architect 자격증에 내용을 맞춰서 클로우드에 대해 설명해 주고 있길래 일단 읽어 보자는 마음에 구매를 먼저 했습니다. 아직 다 못 읽어본 책도 있는데 이것도 틈틈이 읽어야겠습니다.;ㅅ; 이러다가 책 수집하는 게 취미가 될 것 같네요.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;추가&lt;/strong&gt; - 리뷰를 보니 번역상의 오류가 조금씩 있다고 하네요.(예를 들어, ElasticCache -&amp;gt; ElastiCache) 또한 문제의 지문 번역이 애매한 것들도 있다고 하군요. 전 그래도 이런 느낌의 AWS의 책은 처음 보아서 그런지 좀 더 다양한 자격증과 풍부한 내용이 더해진다면 더 좋을 것 같습니다! 계속 천천히 읽어보겠습니다.😊&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/diary/2022-09-28-book.png&quot; alt=&quot;클라우드 AWS 자격증으로 시작하기&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-2022-10-01-170523&quot;&gt;🗓 2022-10-01 17:05:23&lt;/h3&gt;

&lt;p&gt;오늘 파이콘 행사에 참여했습니다. &lt;strong&gt;원티드의 FastAPI&lt;/strong&gt;, &lt;strong&gt;GIL(Global Interpreter Lock)&lt;/strong&gt;, &lt;strong&gt;파이썬 서버리스 웹서비스&lt;/strong&gt; 등의 여러 강의와 오후에는 python을 사용하는(파이콘 후원 업체) 여러 기업의 채용 및 회사 설명에 대해 들었습니다. 영상 재생인데다, 15~40분 내로 강연이 끝나야 하다 보니 강연에 대해서는 조금 아쉬웠지만, 그래도 오후의 채용 설명에서는 정말 좋은 경험이 되었던것 같습니다. 크게 기억에 남았던 것은 두 가지가 있었는데, 첫 번째로는 🌏&lt;a href=&quot;https://soomgo.com/?utm_source=google&amp;amp;utm_medium=cpc&amp;amp;utm_campaign=%EB%A9%94%EC%9D%B8&amp;amp;utm_content=%EB%A9%94%EC%9D%B8&amp;amp;utm_term=%EC%88%A8%EA%B3%A0&amp;amp;gclid=Cj0KCQjwyt-ZBhCNARIsAKH1175qJwAqPpAOgsZJ6R9jbJjsSnUc1I26LoNbVnHAzF3RNFqr-Tt-JVwaAvkMEALw_wcB&quot;&gt;Soomgo&lt;/a&gt;의 채용 프로그램과 애자일 위주로 돌아가는 개발 프로세스였는데, 잘 모른다고 하니 끝나고 나서 하나하나 다 설명해 주시고 끝나고 나서도 절 따로 불러주셔서 부족한 부분에 대해 친절하게 다 설명해 주셨습니다…😀&lt;/p&gt;

&lt;p&gt;두 번째로 🌏&lt;a href=&quot;https://www.dotslashdash.com/&quot;&gt;닷슬래시대시&lt;/a&gt;라는 회사의 조은우 개발자님 이셨는데, 같은 오픈 채팅방에 계신 분이셨습니다. 제 첫 회사가 스타트업이었고 서버 개발자가 저 혼자였던 만큼, 많은 부분에서 공감해주시고 이해해 주셨습니다.😭 또한 서비스 아키텍처 구성, 시스템 설명까지 너무 친절하게 설명해 주셔서 정말 감사했었습니다. 또한 조은우 개발자님께서  함께 있었던 다른 주니어 개발자분들과도 대화를 잘 이끌어서 주셔서 짧지만 알차게 여러 이야기에 대해 들을 수 있었습니다. 오늘 파이콘 참가하신 많은 분들 너무 수고하셨고, 좋은 기회를 주신 파이콘 기획자님들 정말 감사합니다!(추가로, 파이콘 행사 구성품이 꽤나 알찼습니다. 옷, 피규어, 기타 물품들…)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/diary/pycon.png&quot; alt=&quot;pycon 후기 - 왼쪽부터 채용설명회, 경품 추천(친구는 요기요 상품권 당첨됬지만 전 암것도 없습니다..), 파이콘 참여 업체 스티커, 같이간 친구와 스티커 사진&quot; /&gt;
&lt;br /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 25 Sep 2022 15:55:20 +0900</pubDate>
        <link>http://localhost:4000/diary/</link>
        <guid isPermaLink="true">http://localhost:4000/diary/</guid>
        
        
        <category>Diary</category>
        
      </item>
    
      <item>
        <title>스트리밍 서비스와 AWS Media Services</title>
        <description>&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-intro&quot;&gt;💡 Intro&lt;/h2&gt;

&lt;p&gt;Youtube를 보다가 정말 정말 갑자기 스트리밍 서비스에 대해 궁금해졌습니다. 단순히 CDN(Content Delivery Network)을 사용한다 정도만 알고 있었는데, 조금 자세하게 공부를 해보려 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-스트리밍streaming-이란&quot;&gt;🔎 스트리밍(Streaming) 이란?&lt;/h2&gt;

&lt;p&gt;스트리밍 서비스란 &lt;strong&gt;인터넷에서 음성,미디어 컨텐츠를 실시간으로 재생하는 방식&lt;/strong&gt;을 뜻합니다. 이러한 스트리밍 서비스에는 &lt;strong&gt;Progressive download, RTSP, RTMP 스트리밍, Adaptive HTTP Streaming&lt;/strong&gt; 등 여러가지 프로토콜이 있습니다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;프로그레시브 다운로드(Progressive Download)&lt;/strong&gt; : 웹 서버로부터 동영상을 다운로드하면서 파일이 도착하는 대로 재생해주는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;웹서버에 파일을 올려놓고 URL주소를 player에 링크만 걸면 되므로 사용이 편리함&lt;/li&gt;
  &lt;li&gt;동영상이 끊김없이 재생되기 위해서는 네트워크 속도가 동영상의 데이터 레이트 보다 높아야 함&lt;/li&gt;
  &lt;li&gt;내컴퓨터로 파일을 다운로드 하는 것이기 때문에 보안에 문제가 있어 유료 비디오 서비스를 위해서는 사용할 수 없음&lt;/li&gt;
  &lt;li&gt;데이터 소비가 사용자가 보는 만큼이 아니라 다운로드 된 만큼 소비&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;RTSP/RTMP 스트리밍(RSTP/RTMP Streaming)&lt;/strong&gt; : 프로그레시브 다운로드 방식과는 달리 사용자가 현재 시청하고 있는 비디오 프레임만을 전송해주는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;유저가 보는 장면을 찾아 그 프레임부터 시작이 되며, 지나간 프레임 데이터는 자동 삭제되는 방식&lt;/li&gt;
  &lt;li&gt;다운로드가 없어 보안에 문제가 상대적으로 적음&lt;/li&gt;
  &lt;li&gt;필요한 부분만 전송하므로 bandwidth과 데이터 소비에 대해 효율성이 좋음&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;Adaptive HTTP Streaming&lt;/strong&gt; : 미디어 컨텐츠를 동영상 컨텐츠 하나로 저장하는게 아니라 잘게 쪼개서 저장하는 방식. 대표적으로 Apple에서 만든 &lt;strong&gt;HLS(HTTP Live Streaming)&lt;/strong&gt; 가 있음&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;HLS(HTTP Live Streaming)&lt;/strong&gt; : HTTP 프로토콜을 사용하는 실시간 스트리밍 방식으로, 스트리밍 데이터를 m3u8의 확장자를 가진 재생목록 파일과 잘게 쪼갠 다수의 ts파일을 http을 통해 전송하는 방식&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HTTP를 프로토콜을 사용하며 HTML5 및 미디어 소스 확장으로 모든 장치의 호환성이 높으므로 도입 비용을 절약할 수 있음&lt;/li&gt;
  &lt;li&gt;적응형 스트리밍 방식으로 인터넷 속도에 따른 품질이 동적으로 조정됨&lt;/li&gt;
  &lt;li&gt;일반적인 프로토콜은 UDP형식으로 만들어진데 반해, HLS는 TCP형식이라서 라이브 스트림일 때 Delay 문제가 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/streaming/hls.png&quot; alt=&quot;HLS의 구성&quot; /&gt;&lt;em&gt;이미지 1. HLS의 구성(출처: Apple Documentation Archive)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;유튜브에서 원래 프로그레시브 다운로드 방식을 사용하다가 현재는 Adaptive HTTP Streaming 방식을 사용하고 있다고 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-aws-media-services를-통한-라이브-및-온디맨드-동영상-워크플로-구성-및-배포하기&quot;&gt;🔎 AWS Media Services를 통한 라이브 및 온디맨드 동영상 워크플로 구성 및 배포하기&lt;/h2&gt;

&lt;p&gt;이를 이제 AWS에서 어떻게 배포할 수 있을지에 대해서 찾아보았는데… 🌏&lt;a href=&quot;https://www.youtube.com/playlist?list=PLORxAVAC5fUWPziIFAho12lvGl1hR7ZZ5&quot;&gt;AWS Builders 온라인 2021&lt;/a&gt;에서 &lt;strong&gt;김영진님&lt;/strong&gt;께서 이 내용을 다루어주셨더라구요!(AWS…..너란 클라우드..) 서비스를 너무 잘 소개해 주셔서 아래에 Youtube 영상 주소를 올리겠습니다. 이미지를 클릭하시면 해당 영상으로 이동됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://youtu.be/fdoaUq49dSA?list=PLORxAVAC5fUWPziIFAho12lvGl1hR7ZZ5&quot;&gt;&lt;img src=&quot;/assets/images/streaming/youtube.png&quot; alt=&quot;AWS 미디어서비스를 통한 라이브 및 온디맨드 동영상 워크플로 구성 및 배포하기 - 김영진:: AWS Builders Online Series&quot; /&gt;&lt;em&gt;클릭시 Youtube로 이동됨&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;영상을 시청하시면 &lt;strong&gt;Live Streaming&lt;/strong&gt;과 &lt;strong&gt;VOD(Video On Demand) streaming&lt;/strong&gt; 두 가지다 개념부터 워크플로, Demo 버전을 만드는 것까지 자세하게 설명하고 있습니다. 그래서 저는 영상에 나오는 기본적인 AWS 서비스들에 대해서 따로 정리해 보려고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/streaming/workflow.png&quot; alt=&quot;AWS 미디어 서비스를 이용한 워크플로우&quot; /&gt;&lt;em&gt;이미지 2. AWS 미디어 서비스를 이용한 워크플로우(출처: AWS Youtube)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-영상속-aws-서비스-정리&quot;&gt;🔎 영상속 AWS 서비스 정리&lt;/h2&gt;

&lt;h3 id=&quot;-aws-media-services&quot;&gt;🌎 AWS Media Services&lt;/h3&gt;

&lt;p&gt;🌏&lt;a href=&quot;https://aws.amazon.com/ko/media-services/&quot;&gt;AWS Media Services&lt;/a&gt;는 클라우드에서 안정적인 브로드캐스트 품질의 비디오 워크플로를 손쉽게 구축할 수 있게 해주는 완전 관리형 서비스 패밀리입니다. 웹을 들어간 후, 상단 메뉴에 있는 서비스를 클릭하면 다양한 제품들을 확인할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;aws-elemental-medialive&quot;&gt;&lt;strong&gt;AWS Elemental MediaLive&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AWS ElementalMediaLive는 브로드캐스트 및 스트리밍 전송을 위한 라이브 출력을 생성할 수 있는 실시간 비디오 서비스입니다. 이 서비스를 사용하면 텔레비전과 인터넷 연결 멀티스크린 디바이스(커넥티드 TV, 태블릿, 스마트폰, 셋톱 박스 등)로 전송할 수 있는 고품질 비디오 스트림을 생성할 수 있습니다.&lt;/code&gt; &lt;span style=&quot;color:gray; font-size:2px;&quot;&gt;- 출처: AWS Docs&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;AWS Elemental MediaLive는 Live 비디오 스트림을 실시간으로 인코딩하고 배포하는 서비스입니다. 쉽게 설명하자면, 고해상도의 입력신호를 적합한 화질로 변환해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;aws-elemental-mediapackage&quot;&gt;&lt;strong&gt;AWS Elemental MediaPackage&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;MediaPackage는 AWS 클라우드에서 실행되는 적시 비디오 패키징 및 오리지네이션 서비스입니다. MediaPackage를 사용하면 매우 안전하고 확장 가능하며 신뢰할 수 있는 비디오 스트림을 다양한 재생 디바이스 및 CDN(콘텐츠 전송 네트워크, 여기서는 Amazon CloudFront)에 전달할 수 있습니다.&lt;/code&gt; &lt;span style=&quot;color:gray; font-size:2px;&quot;&gt;- 출처: AWS - MediaPackage&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MediaPackage&lt;/strong&gt;는 단일 비디오 입력으로부터 커넥티드 TV, 휴대폰, 컴퓨터, 태블릿 및 게임 콘솔에 맞는 형식으로 비디오 스트림을 생성해줍니다. 또한, 인기 있는 비디오 기능(다시 시작, 정지, 되감기 등)을 손쉽게 구현할 수 있고 DRM(Digital Rights Management)을 사용해 콘텐츠를 보호해준다고 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;DRM(Digital Right Management)&lt;/strong&gt; 이란 정보보호 기술 중 하나로 암호화 기술을 이용해서 비허가 사용자로부터 디지털 컨텐츠를 보호하게 하는 기술을 말합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;AWS Elemental MediaPackage는 &lt;strong&gt;라이브 패키징&lt;/strong&gt;과 &lt;strong&gt;VOD 패키징&lt;/strong&gt;이라는 &lt;u&gt;두 가지 요금 모델&lt;/u&gt;을 제공합니다. 라이브 패키징의 경우 채널로 수집된 비디오의 양(GB로 측정)과 채널에 대해 오리지네이션 및 패키징된 콘텐츠의 양(GB로 측정)에 따라 요금이 부과됩니다. VOD 패키징을 사용하면 VOD 패키징 그룹에서 오리지네이션 및 패키징된 비디오 컨텐츠의 양(GB로 측정)에 따라 요금이 청구됩니다. 자세한 요금 사항은 🌏&lt;a href=&quot;https://aws.amazon.com/ko/mediapackage/pricing/&quot;&gt;AWS Elemental MediaPackage 요금&lt;/a&gt;을 확인해 주세요.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;aws-elemental-mediastore&quot;&gt;&lt;strong&gt;AWS Elemental MediaStore&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AWS Elemental MediaStore는 미디어에 최적화된 AWS 스토리지 서비스입니다. 이는 라이브 스트리밍 비디오 콘텐츠를 전송하는 데 필요한 성능, 일관성 및 짧은 지연 시간을 제공합니다. AWS Elemental MediaStore는 비디오 워크플로에서 오리진 스토어의 역할을 합니다. 이 서비스의 뛰어난 성능은 비용 효율적인 장기 스토리지와 결합되어 가장 까다로운 미디어 전송 워크로드의 요건을 충족합니다.&lt;/code&gt; &lt;span style=&quot;color:gray; font-size:2px;&quot;&gt;- 출처: AWS - MediaStore&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Docs를 읽고나면 S3와의 차이점에 대해 궁금하실텐데, Docs에 적힌데로 MediaStore는 &lt;strong&gt;미디어에 최적화된 AWS 스토리지 서비스&lt;/strong&gt;입니다. cacheing layer가 있으며 S3보다 latency가 짧기 때문에 &lt;strong&gt;라이브 비디오에는 MediaStore&lt;/strong&gt;를, &lt;strong&gt;VOD(Video On Demand)에는 S3&lt;/strong&gt;를 사용한다고 합니다.&lt;/p&gt;

&lt;p&gt;AWS Elemental MediaStore는 콘텐츠가 서비스에 도달할 때 GB당 &lt;strong&gt;미디어 최적화 수집 비용&lt;/strong&gt;이 부과되고, 라이브 및 VOD 전송을 위해 서비스에 유지하는 콘텐츠에 대해 GB당 &lt;strong&gt;콘텐츠 스토리지 비용&lt;/strong&gt;이 부과됩니다. 자세한 요금 사항은 🌏&lt;a href=&quot;https://aws.amazon.com/ko/mediastore/pricing/&quot;&gt;AWS Elemental MediaStore 요금&lt;/a&gt;을 확인해 주세요.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;aws-elemental-mediatailor&quot;&gt;&lt;strong&gt;AWS Elemental MediaTailor&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AWS Elemental MediaTailor는 비디오 공급자가 브로드캐스트 수준의 서비스 품질을 떨어뜨리지 않고 비디오 스트림에 개별적으로 타겟 광고를 삽입할 수 있는 서비스입니다.&lt;/code&gt; &lt;span style=&quot;color:gray; font-size:2px;&quot;&gt;- 출처: AWS - MediaStore&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/streaming/MediaConvert.png&quot; alt=&quot;AWS Elemental MediaTailor 작동 방식&quot; /&gt;&lt;em&gt;이미지 3. AWS Elemental MediaTailor 작동 방식(출처: AWS - MediaTailor)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;즉, &lt;strong&gt;AWS Elemental MediaTailor&lt;/strong&gt;란 수익 창출을 위한 광고 삽입 서비스입니다. MediaTailor는 클라이언트 측과 서버 측 광고 전달 지표 둘 다를 기준으로 자동화된 보고서를 제공해주기 때문에, 광고 노출 수와 시청자 동작을 정확하게 측정할 수 있다고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;aws-elemental-mediaconvert&quot;&gt;&lt;strong&gt;AWS Elemental MediaConvert&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AWS Elemental MediaConvert 콘텐츠 소유자와 배포업체에게 모든 규모의 미디어 라이브러리에 대한 확장 가능한 비디오 처리를 제공하는 파일 기반 비디오 처리 서비스입니다. MediaConvert 에서는 다음과 같은 프리미엄 콘텐츠 경험을 지원하는 고급 기능을 제공합니다.&lt;/code&gt; &lt;span style=&quot;color:gray; font-size:2px;&quot;&gt;- 출처: AWS Docs&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/streaming/MediaConvert.png&quot; alt=&quot;AWS Elemental MediaConvert 작동 방식&quot; /&gt;&lt;em&gt;이미지 4. AWS Elemental MediaConvert 작동 방식(출처: AWS - MediaConvert)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;즉, 디바이스로 전달할 영상 파일을 인코딩 해주는 역할을 해주고 있습니다. 요금은 베이직 티어와 프로페셔널 티어로 나뉘어져 있고, 프로페셔널이 베이직 보다 1.5배 이상 비싸기 때문에 제공하는 서비스에 따라서 잘 선택하셔야 할 것 같습니다.🤔 자세한 사항은 🌏&lt;a href=&quot;https://aws.amazon.com/ko/mediaconvert/pricing/&quot;&gt;AWS Elemental MediaConvert 요금&lt;/a&gt;에서 확인 하시면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-other-aws-services&quot;&gt;🌎 Other AWS Services&lt;/h3&gt;

&lt;h4 id=&quot;amazon-s3&quot;&gt;&lt;strong&gt;Amazon S3&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Amazon Simple Storage Service(Amazon S3)는 업계 최고의 확장성, 데이터 가용성, 보안 및 성능을 제공하는 객체 스토리지 서비스입니다. 모든 규모와 업종의 고객은 Amazon S3를 사용하여 데이터 레이크, 웹 사이트, 모바일 애플리케이션, 백업 및 복원, 아카이브, 엔터프라이즈 애플리케이션, IoT 디바이스, 빅 데이터 분석 등 다양한 사용 사례에서 원하는 양의 데이터를 저장하고 보호할 수 있습니다. Amazon S3는 특정 비즈니스, 조직 및 규정 준수 요구 사항에 맞게 데이터에 대한 액세스를 최적화, 구조화 및 구성할 수 있는 관리 기능을 제공합니다.&lt;/code&gt; &lt;span style=&quot;color:gray; font-size:2px;&quot;&gt;- 출처: AWS Docs&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Amazon S3는 데이터를 저장하고 검색할 수 있는 간단한 API를 제공하는 완전 관리형 스토리지 서비스입니다. 즉, Amazon S3에 저장하는 데이터는 특정 서버와 관련이 없으므로 사용자가 인프라를 직접 관리할 필요가 없습니다. 또한 일반적인 파일 서버는 사용자 트래픽이 증가하면 스토리지 증설 작업을 해야하지만 S3는 시스템 적으로 트래픽 증가에 대한 처리를 미리 해두었기 때문에 파일 서버 관리자는 별도의 처리를 해주지 않아도 됩니다. bucket(최상위 디렉토리)이라는 폴더에 Object(S3에 저장되는 데이터)인 파일을 저장하여 사용합니다. 🌏&lt;a href=&quot;https://aws.amazon.com/ko/s3/pricing/&quot;&gt;Amazon S3 Simple Storage Service 요금 - AWS&lt;/a&gt;이곳에서 요금에 대한 정보를 확인하실 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;aws-step-functions&quot;&gt;&lt;strong&gt;AWS Step Functions&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AWS Step Functions은 시각적 워크플로우를 사용해 분산 애플리케이션 및 마이크로서비스의 구성 요소를 손쉽게 조정하도록 해주는 웹 서비스입니다. 각각 기능 또는 작업을 수행하는 개별 구성 요소를 사용하여 애플리케이션을 구축하면 애플리케이션을 빠르게 확장하거나 변경할 수 있습니다.&lt;/code&gt; &lt;span style=&quot;color:gray; font-size:2px;&quot;&gt;- 출처: AWS Docs&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;쉽게 설명하면 AWS의 여러 컴퓨팅 자원들의 수행 순서를 시각적으로 설정할 수 있는 서비스입니다. 또한, AWS Lambda같은 경우는 상태 값이 없어서 데이터를 확인하려면 DB에서 데이터를 확인했는데, Step Functions을 활용해서 Lambda 함수를 각 단계에 설정할 수 있다고 합니다. Step Function은 진행중인 단계에 맞게 처리할 데이터를 Lambda 함수에 보내주게할 수 있는데, 이렇게 하면 원하는 상태 정보를 알 수 있게 되고 각각의 워크플로우들을 한눈에 관리할 수 있다고 합니다.(이전에 처음으로 Lambda를 이용할 때는 Step Functions대해 몰랐었었는데, 한번 써볼 기회가 생겼으면 좋겠네요!😃)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;amazon-cloudfront&quot;&gt;&lt;strong&gt;Amazon CloudFront&lt;/strong&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Amazon CloudFront는 .html, .css, .js 및 이미지 파일과 같은 정적 및 동적 웹 콘텐츠를 사용자에게 더 빨리 배포하도록 지원하는 웹 서비스입니다. CloudFront는 엣지 로케이션이라고 하는 데이터 센터의 전 세계 네트워크를 통해 콘텐츠를 제공합니다. CloudFront를 통해 서비스하는 콘텐츠를 사용자가 요청하면 지연 시간이 가장 낮은 엣지 로케이션으로 요청이 라우팅되므로 가능한 최고의 성능으로 콘텐츠가 제공됩니다.&lt;/code&gt; &lt;span style=&quot;color:gray; font-size:2px;&quot;&gt;- 출처: AWS Docs&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;즉, &lt;strong&gt;CloudFront는 AWS에서 제공하는 CDN 서비스&lt;/strong&gt; 입니다. 사용자로부터 요청이 발생하면 요청이 발생한 &lt;strong&gt;Edge Server(컨텐츠들이 캐시에 보관되어지는 장소)&lt;/strong&gt; 은 요청이 발생한 데이터에 대하여 캐싱 여부를 확인합니다. 그리고 캐싱 데이터가 존재하면 사용자에 요청에 맞게 응답하고 존재하지 않으면 &lt;strong&gt;Origin Server(원본 데이터를 가지고 있는 서버, S3/Ec2 instance)&lt;/strong&gt; 로 요청합니다. 요청 받은 데이터에 대해 Origin Server로부터 전달 받은 Edge Server는 캐싱 데이터를 생성하고 사용자에게 응답하게 됩니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;CDN(Content Delivery Network, 콘텐츠 전송 네트워크)&lt;/strong&gt; 이란? 지리적 제약 없이 전 세계 사용자에게 빠르고 안전하게 콘텐츠를 전송할 수 있는 콘텐츠 전송 기술입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/streaming/CloudFront.png&quot; alt=&quot;CloudFront에서 사용자에게 콘텐츠를 제공하는 방법&quot; /&gt;&lt;em&gt;이미지 5. CloudFront에서 사용자에게 콘텐츠를 제공하는 방법(출처: AWS Docs)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;CloudFront 함수는 글로벌 CloudFront 이벤트에 대한 응답으로 함수를 실행할 때마다 호출 횟수를 계산합니다. 자세한 요금 사항은 🌏&lt;a href=&quot;https://aws.amazon.com/ko/cloudfront/pricing/&quot;&gt;Amazon CloudFront CDN - 요금제 및 요금&lt;/a&gt;에서 확인하실 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;끝맺음&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;오늘은 스트리밍 서비스에 대해 정리를 해보았습니다. 저는 미디어에 대한 지식이 많이 부족하기 때문에, 생각보다 정리할 것이 많았고(깊게 들어가면 훨씬 많은 내용이 있습니다..) 적지 않은 시간을 쓴 것 같습니다.🥲 다행히 Live Streaming과 VOD streaming 두 가지다 AWS Media Services를 사용한 워크플로(AWS에서 제시해 준)로 구축할 수 있기 때문에 조금 더 쉽게 공부를 한 것 같습니다.&lt;/p&gt;

&lt;p&gt;AWS Media Services의 서비스들이 아직 서울 리전이 나온 지 얼마 안 되어서 그런지 AWS를 이용한 미디어 서비스 구축 후기에 관한 한국 자료는 많이 찾아볼 수 없었습니다. 그래도 AWS에서 서비스에 대한 정보를 잘 제공해 주기 때문에, 스트리밍 서비스 구축에 고민하고 계신 분들은 AWS Media Services를 잘 활용한다면 안전하고 빠르게 스트리밍 서비스를 구축해볼 수 있을 것 같습니다. 부족한 내용이지만 읽어주셔서 감사합니다.😀 잘못된 내용은 댓글로 남겨주시면 감사하겠습니다!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[참고자료]&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=fdoaUq49dSA&quot;&gt;AWS 미디어서비스를 통한 라이브 및 온디맨드 동영상 워크플로 구성 및 배포하기 - 김영진:: AWS Builders Online Series&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/&quot;&gt;AWS Docs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/media-services/&quot;&gt;AWS&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.leedoing.com/184&quot;&gt;이두잉의 AWS 세상 - AWS Step Functions 이해&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://velog.io/@doohyunlm/AWS-CloudFront-개념&quot;&gt;AWS CloudFront - 개념&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 15 Sep 2022 20:08:49 +0900</pubDate>
        <link>http://localhost:4000/streaming/</link>
        <guid isPermaLink="true">http://localhost:4000/streaming/</guid>
        
        
        <category>CDN</category>
        
        <category>AWS</category>
        
      </item>
    
      <item>
        <title>ALB(Application Load Balancer)에서 URL 기반 라우팅</title>
        <description>&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-intro&quot;&gt;💡 Intro&lt;/h2&gt;

&lt;p&gt;하나의 도메인에 두 개의 서비스를 할 수 있는지에 대해 묻는 분이 있었습니다. AWS에서 어떻게 구성해야 하는지 🌎&lt;a href=&quot;https://aws.amazon.com/ko/premiumsupport/knowledge-center/elb-achieve-path-based-routing-alb/&quot;&gt;AWS Docs&lt;/a&gt;를 찾아보다가 ALB(Application Load Balancer)로 가능하다는 것을알게 되었습니다. 이를 URL 기반 라우팅이라고 하는데, 이에 대해서 실습해 보려 합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;⚠️ Classic Load Balancer, Network Load Balancer 및 Gateway Load Balancer 등 다른 로드 밸런서 유형에는 이 기능을 사용할 수 없습니다. ELB는 AWS를 사용하는 분에게는 기본적으로 숙지해야하는 내용이라고 들었기 때문에 초보 개발자인 저도 열심히 공부하고 있습니다.😭&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-albapplication-load-balancer란&quot;&gt;🔎 ALB(Application Load Balancer)란?&lt;/h2&gt;

&lt;p&gt;ELB(Elastic Load Balancing) 설명서에는 ALB(Application Load Balancer)에 대해 이렇게 설명 하고 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Application Load Balancer는 개방형 시스템 간 상호 연결(OSI) 모델의 일곱 번째 계층인 애플리케이션 계층에서 작동합니다. 로드 밸런서는 요청을 받으면 우선 순위에 따라 리스너 규칙을 평가하여 적용할 규칙을 결정한 다음, 규칙 작업의 대상 그룹에서 대상을 선택합니다. 애플리케이션 트래픽의 콘텐츠를 기반으로 다른 대상 그룹에 요청을 라우팅하도록 리스너 규칙을 구성할 수 있습니다. 대상이 여러 개의 대상 그룹에 등록이 된 경우에도 각 대상 그룹에 대해 독립적으로 라우팅이 수행됩니다. 대상 그룹 레벨에서 사용되는 라우팅 알고리즘을 구성할 수 있습니다. 기본 라우팅 알고리즘은 라운드 로빈입니다. 그 대신 최소 미해결 요청 라우팅 알고리즘을 지정할 수 있습니다.&lt;/code&gt; &lt;span style=&quot;color:gray; font-size:2px;&quot;&gt;- 출처: AWS Docs&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Application layer&lt;/strong&gt;는 OSI 7 Layer의 제일 꼭대기에 있는 계층입니다. 애플리케이션과 데이터를 주고 받기 위한 역할을 하는데, 서버가 이해할 수 있는 메시지(데이터)로 변환하고, 전송 계층에 전달하는 역할을 수행합니다. 애플리케이션 계층에는 웹 사이트를 이용할 때의 HTTP 프로토콜, 파일을 전송할 때 쓰는 FTP 프로포콜, 메일을 보낼 때 쓰는 SMTP 프로토콜 등 다양한 프로토콜이 존재합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;아래 이미지와 같이 Load Balancer 아래에는 &lt;strong&gt;Listener, Rule, Target Group&lt;/strong&gt;이 있습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Listener : 구성한 프로토콜 및 포트를 사용하여 클라이언트의 연결 요청을 확인하여 요청을 처리할 적절한 Target Group으로 전달합니다.&lt;/li&gt;
  &lt;li&gt;Rule : 어떤 대상그룹에 전달해야 할지를 판단하는 기준이 됩니다.&lt;/li&gt;
  &lt;li&gt;Target Group : 클라이언트의 요청을 처리할 EC2 인스턴스의 집합이며, 지정한 프로토콜과 포트 번호를 사용하여 요청을 라우팅합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/alb/alb-element.png&quot; alt=&quot;ALB 구성 요소&quot; /&gt;&lt;em&gt;이미지 1. ALB 구성 요소(출처: AWS Docs)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;ALB는 하나 이상의 Listener를 추가할 수 있으며, Listener에는 다수의 Rule을 가질 수 있고, Listener 또한 다수의 Target Group을 가질 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-alb에서-url-기반-라우팅을-수행해-보기&quot;&gt;📚 ALB에서 URL 기반 라우팅을 수행해 보기&lt;/h2&gt;

&lt;p&gt;AWS Docs를 따라서 진행해 보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;서비스 A와 서비스 B라는 두 가지 서비스가 있고 애플리케이션이 포트 80의 이러한 서비스에서 실행되고 있다고 가정합니다. 예를 들어 서비스 A는 /svcA 경로에서 애플리케이션을 실행하고, 서비스 B는 /svcB 경로에서 애플리케이션을 실행합니다.&lt;/code&gt; &lt;span style=&quot;color:gray; font-size:2px;&quot;&gt;- 출처: AWS Docs&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;-elbapplication-load-balancer-생성&quot;&gt;📕 ELB(Application Load Balancer) 생성&lt;/h3&gt;

&lt;p&gt;[EC2 대시보드]에서 [로드 벨런서]를 들어간 뒤 [로드 밸런서 생성]을 들어갑니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/alb/create-alb1.png&quot; alt=&quot;AWS Console &amp;gt; EC2 &amp;gt; 로드 밸런서 생성&quot; /&gt;&lt;em&gt;이미지 2. 로드 밸런서 생성&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;[Select load balancer type]에서 [Application Load Balancer]를 Create합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/alb/create-alb2.png&quot; alt=&quot;Application Load Balancer 생성&quot; /&gt;&lt;em&gt;이미지 3. Application Load Balancer 생성 - 1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Load balancer name, VPC, 가용영역을 설정한 후 Summary를 확인하고 생성합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/alb/create-alb3.png&quot; alt=&quot;Application Load Balancer 생성&quot; /&gt;&lt;em&gt;이미지 4. Application Load Balancer 생성 - 2&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Internet-facing(인터넷경계)&lt;/strong&gt; 란, 이름에서 느껴지는 것처럼 인터넷에 연결되는 밸런서를 뜻합니다. 인터넷으로부터 요청을 받아서 각기 다른 EC2로 분배해 주는 역할을 합니다. &lt;strong&gt;Internal(내부)&lt;/strong&gt; 는, private subnet에 연결되어 있는 여러 서버에 연결될 때 사용합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/alb/create-alb4.png&quot; alt=&quot;Application Load Balancer 생성&quot; /&gt;&lt;em&gt;이미지 5. Application Load Balancer 생성 - 3&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;로드 밸런서 [my-alb]가 생성된 것을 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/alb/create-alb5.png&quot; alt=&quot;Application Load Balancer 생성&quot; /&gt;&lt;em&gt;이미지 6. Application Load Balancer 생성 - 4&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-listeners-규칙-구성&quot;&gt;📘 Listeners 규칙 구성&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;리스너 규칙 1: 요청 URL 경로에 /svcA 문자열이 포함되어 있으면 요청을 my-tg1로 전달합니다. my-tg1에는 지정된 경로에서 애플리케이션을 실행하는 서비스 A가 포함되어 있기 때문입니다. 리스너 규칙 2: 요청 URL 경로에 /svcB 문자열이 포함되어 있으면 해당 요청을 my-tg2로 전달합니다. my-tg2에는 지정된 경로에서 애플리케이션을 실행하는 서비스 B가 포함되어 있기 때문입니다.&lt;/code&gt; &lt;span style=&quot;color:gray; font-size:2px;&quot;&gt;- 출처: AWS Docs&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;[로드 밸런서]를 선택한 다음 [리스너(Listeners)]를 선택합니다. 그리고 리스너를 업데이트하기 위해 [규칙 보기/편집(View/edit rules)]을 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/alb/listeners1.png&quot; alt=&quot;Listeners 업데이트&quot; /&gt;&lt;em&gt;이미지 7. 리스너 규칙 보기/편집&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;상단의 메뉴에서 규칙 추가(Add rules) 아이콘인 [더하기 기호(+)]를 선택합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/alb/listeners2.png&quot; alt=&quot;규칙 추가&quot; /&gt;&lt;em&gt;이미지 8. 리스너 규칙 추가 - 1&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;우선 순위에 따라 규칙을 삽입할 수 있는 [규칙 삽입(Insert Rule) 아이콘]을 클릭합니다.&lt;/li&gt;
  &lt;li&gt;/svcA와 /svcB에 경로 기반 규칙 추가를 위해 IF(모두 일치) 부분에서 [조건 추가(Add condition)]를 클릭 후, [경로(Path)]를 선택한 다음 경로 패턴 /svcA를 입력합니다.&lt;/li&gt;
  &lt;li&gt;THEN 부분에서 [작업 추가(Add action)]를 클릭한 후, [전달(Forward to)]을 선택한 다음 대상 그룹 my-tg1를 선택합니다.&lt;/li&gt;
  &lt;li&gt;/svcB 또한 똑같이 설정해 줍니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/alb/listeners3.png&quot; alt=&quot;규칙 추가&quot; /&gt;&lt;em&gt;이미지 9. 리스너 규칙 추가 - 2&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Application Load Balancer의 DNS 이름을 복사하여 URL 경로 끝에 &lt;strong&gt;/svcA&lt;/strong&gt; or &lt;strong&gt;/svcA&lt;/strong&gt; 를 붙여 넣었을 때, 올바른 서비스를 반환하면 테스트가 성공적으로 이루어집니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[참고자료]&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/premiumsupport/knowledge-center/elb-achieve-path-based-routing-alb/&quot;&gt;Application Load Balancer에서 경로 기반 라우팅을 수행하려면 어떻게 해야 하나요?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/elasticloadbalancing/latest/application/introduction.html&quot;&gt;AWS docs - Application Load Balancer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/elasticloadbalancing/latest/application/listener-update-rules.html&quot;&gt;Listener rules for your Application Load Balancer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws-hyoh.tistory.com/133&quot;&gt;https://aws-hyoh.tistory.com/133&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 31 Aug 2022 14:40:22 +0900</pubDate>
        <link>http://localhost:4000/alb/</link>
        <guid isPermaLink="true">http://localhost:4000/alb/</guid>
        
        
        <category>AWS</category>
        
        <category>ALB</category>
        
      </item>
    
      <item>
        <title>VPC내의 AWS Lambda의 인터넷 접속하기</title>
        <description>&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-intro&quot;&gt;💡 Intro&lt;/h2&gt;

&lt;p&gt;Amazon Virtual Private Cloud(Amazon VPC)에 연결된 AWS Lambda에 인터넷 접속을 가능하게 하려면, NAT GW(Network Address Translation Gateway) 설정을 해야합니다. 오늘은 이에 대해서 정리해 보려고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-aws-lambda의-세-가지-상태&quot;&gt;🔎 AWS Lambda의 세 가지 상태&lt;/h2&gt;

&lt;p&gt;저는 Amazon Virtual Private Cloud(Amazon VPC)에 연결된 &lt;strong&gt;AWS Lambda&lt;/strong&gt;에 인터넷 접속을 가능하게 하기 위해, 3번째 케이스인 &lt;strong&gt;VPC&lt;/strong&gt;와 &lt;strong&gt;NAT&lt;/strong&gt;이 있는 상태로 진행해보도록 하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;VPC&lt;/strong&gt;가 없는 상태 : 웹에 자유롭게 접속할 수 있지만, 로컬 네트워크로 AWS 서비스들과 연결할 수 없습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;VPC&lt;/strong&gt;가 있는 상태 : 기본적인 설정으로 로컬 네트워크에 연결이 가능하지만, 웹에는 접속할 수 없습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;VPC&lt;/strong&gt;와 &lt;strong&gt;NAT&lt;/strong&gt;이 있는 상태 : AWS 서비스와 웹 둘 다 접속이 가능합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-amazon-vpcamazon-virtual-private-cloud-subnet-router-routing-table-igwinternet-gateway-nat-gwnetwork-address-translation-gateway란&quot;&gt;🔎 Amazon VPC(Amazon Virtual Private Cloud), Subnet, Router, Routing Table, IGW(Internet Gateway), NAT GW(Network Address Translation Gateway)란?&lt;/h2&gt;

&lt;p&gt;본 내용에 들어가기전, &lt;strong&gt;Amazon VPC&lt;/strong&gt;, &lt;strong&gt;Subnet&lt;/strong&gt;, &lt;strong&gt;Routing Table&lt;/strong&gt;, &lt;strong&gt;IGW&lt;/strong&gt;, &lt;strong&gt;NAT GW&lt;/strong&gt;에 대해서 먼저 정리하고 넘어가 보도록 하겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;-amazon-vpcamazon-virtual-private-cloud&quot;&gt;🌎 Amazon VPC(Amazon Virtual Private Cloud)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Amazon VPC&lt;/strong&gt;란, AWS 클라우드에서 다른 고객과 완벽하게 논리적으로 격리된 네트워크 공간을 제공하여 프로비저닝하여 가상 네트워크에서 AWS 리소스를 만드는데 사용하는 리소스입니다. 쉽게 풀어서 설명하자면, 자신이 사용할 AWS Resource들을 격리 되어진 하나의 네트워크로 묶는 서비스를 의미하며 격리되어 있기 때문에 다른 사람들은 접근하고 보는 것이 불가능해집니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;만약, VPC 없이 인스턴스를 생성한다면 아래와 같이 인스턴스끼리의 구분없는 연결로 인해 시스템 복잡도가 증가할 것이며, 인터넷을 통해 전달되는 트래픽의 전송이 굉장히 비효율적이게 될 것 입니다. VPC를 적용하면 인스턴스가 VPC에 속함으로써 네트워크를 구분할 수 있고, VPC 별로 필요한 설정을 통해 인스턴스에 네트워크 설정을 적용할 수 있습니다. 또한, 각각의 VPC는 독립적이기 때문에 서로 통신할 수 없습니다. 만일 통신을 원한다면 VPC 피어링 서비스를 통해 VPC 간에 트래픽을 라우팅할 수 있도록 설정할 수 있습니다. ➕ AWS는 VPC의 중요성을 강조하여 2019년부터 거의 모든 서비스에 VPC를 적용하도록 강제하였습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lambda-nat/vpc.png&quot; alt=&quot;Amazon VPC&quot; /&gt;&lt;em&gt;이미지 1. Amazon VPC&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-서브넷subnet&quot;&gt;🌎 서브넷(Subnet)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;서브넷(Subnet)&lt;/strong&gt; 이란, IP 주소를 나누어 리소스가 배치되는 물리적인 주소 범위입니다. 즉, 서브넷은 VPC를 잘 개 쪼갠 것이며 서브넷을 나누는 이유는 더 많은 네트워크 망을 만들기 위함입니다. 또한 인터넷에 연결되어야 하는 리소스에는 퍼블릭 서브넷(Public Subnet)을 사용하고, 인터넷에 연결되지 않는 리소스에는 프라이빗 서브넷(Private Subnet)을 사용합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이처럼 인터넷 연결 여부로 퍼블릭 서브넷(Public Subnet)과 프라이빗 서브넷(Private Subnet)로 구분하는 이유는 보안을 강화하기 위함입니다. 퍼블릭 서브넷에 존재하는 인스턴스는 인터넷에 연결되어 아웃바운드, 인바운드 트래픽을 주고받을 수 있습니다. 반면 프라이빗 서브넷은 외부에 노출이 되어 있지 않기 때문에 접근할 수 없습니다. 즉, 인터넷과 연결되어 외부에 노출되어 있는 면적을 최소화함으로써 네트워크 망에 함부로 접근하는 것을 막기 위함입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lambda-nat/subnet.png&quot; alt=&quot;Subnet&quot; /&gt;&lt;em&gt;이미지 2. Subnet&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-라우팅-테이블routing-table과-라우터router&quot;&gt;🌎 라우팅 테이블(Routing Table)과 라우터(Router)&lt;/h3&gt;

&lt;p&gt;AWS VPC 설명서에는 라우팅 테이블의 역할이 이렇게 소개되어져 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;VPC에는 암시적 라우터가 있으며 라우팅 테이블을 사용하여 네트워크 트래픽이 전달되는 위치를 제어합니다. VPC의 각 서브넷을 라우팅 테이블에 연결해야 합니다. 테이블에서는 서브넷에 대한 라우팅을 제어합니다(서브넷 라우팅 테이블). 서브넷을 특정 라우팅 테이블과 명시적으로 연결할 수 있습니다. 그렇지 않으면 서브넷이 기본 라우팅 테이블과 암시적으로 연결됩니다. 서브넷은 한 번에 하나의 라우팅 테이블에만 연결할 수 있지만 여러 서브넷을 동일한 서브넷 라우팅 테이블에 연결할 수 있습니다.&lt;/code&gt; &lt;span style=&quot;color:gray; font-size:2px;&quot;&gt;- 출처: AWS Docs&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;간단하게 설명하자면 라우터(Router)는 목적지이고, 라우팅 테이블(Routing Tabl)은 이정표라고할 수 있습니다. &lt;code class=&quot;highlighter-rouge&quot;&gt;172.31.0.0/16가 목적지면 이리로 오고, 10.0.0.0/16가 목적지면 절로 가세요.&lt;/code&gt;라고 알려주는 이정표일 뿐인거죠. 만약 목적지가 라우팅 테이블에 명시되지 않은 트래픽들을 라우팅 시키고 싶을 땐 &lt;code class=&quot;highlighter-rouge&quot;&gt;0.0.0.0/0&lt;/code&gt;라는 주소를 통해 전달시킬 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lambda-nat/router.png&quot; alt=&quot;Router&quot; /&gt;&lt;em&gt;이미지 3. Router&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-igwinternet-gateway-인터넷-게이트웨이--nat-gwnetwork-address-translation-gateway-nat-게이트웨이&quot;&gt;🌎 IGW(Internet Gateway, 인터넷 게이트웨이) / NAT GW(Network Address Translation Gateway, NAT 게이트웨이)&lt;/h3&gt;

&lt;p&gt;사실상 &lt;strong&gt;IGW&lt;/strong&gt;와 &lt;strong&gt;NAT GW&lt;/strong&gt; 이 두 개를 통해 인터넷 간 통신을 활성화시킬 수 있습니다. &lt;strong&gt;IGW&lt;/strong&gt;는 VPC 리소스와 인터넷 간 통신을 활성화하기 위해 VPC에 연결하며, 퍼블릭 서브넷만 외부와 통신해야 하므로 퍼블릭 서브넷의 라우팅 테이블에만 IGW로 향하는 규칙을 포함합니다. &lt;strong&gt;NAT GW&lt;/strong&gt;는 퍼블릭 서브넷에 위치하여 프라이빗 서브넷에서 발생하는 네트워크 요청을 받은 후, IGW에 패킷을 전달하여 인터넷과 통신할 수 있도록 도와줍니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;라우팅 테이블을 보면 0.0.0.0/0으로 되어 있는 것을 볼 수 있는데, 목적지의 IP 주소가 172.31.0.0/16(VPC 내부)에 해당하는지 확인하고 해당하지 않는 모든 트래픽에 대하여 IGW로 보내라는 뜻입니다. 즉, 목적지가 라우팅 테이블에 명시되지 않은 모든 트래픽을 라우팅 시키고 싶을 땐 0.0.0.0/0라는 주소를 사용할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lambda-nat/gateway.png&quot; alt=&quot;IGW / NAT GW&quot; /&gt;&lt;em&gt;이미지 4. IGW / NAT GW&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-vpc내의-aws-lambda의-인터넷-접속하기&quot;&gt;📚 VPC내의 AWS Lambda의 인터넷 접속하기&lt;/h2&gt;

&lt;p&gt;이제 본격적으로 작업을 실시할 수 있습니다. 🌎&lt;a href=&quot;https://aws.amazon.com/ko/premiumsupport/knowledge-center/internet-access-lambda-function/&quot;&gt;Amazon Virtual Private Cloud(Amazon VPC)에 연결된 AWS Lambda 함수에 인터넷 액세스를 제공하려 합니다. 어떻게 설정해야 하나요?&lt;/a&gt; 문서에 자세하게 나와있습니다. 그냥 이 순서 그대로 따라하시면 진행하는데 전혀 큰 어려움은 없습니다.&lt;/p&gt;

&lt;h3 id=&quot;-amazon-vpc-설정&quot;&gt;📕 Amazon VPC 설정&lt;/h3&gt;

&lt;p&gt;AWS Console &amp;gt; VPC로 들어가면, &lt;strong&gt;VPC, Subnet, Routing Table, IGW, NAT GW&lt;/strong&gt;등 앞서 정리한 모든 항목이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lambda-nat/vpc_console.png&quot; alt=&quot;AWS Console &amp;gt; VPC&quot; /&gt;&lt;em&gt;이미지 5. AWS Console -&amp;gt; VPC&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. Amazon VPC를 생성합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AWS Console &amp;gt; VPC &amp;gt; VPC 생성&lt;/li&gt;
  &lt;li&gt;이름 및 IPv4를 지정 / 생성해줍니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lambda-nat/create_vpc1.png&quot; alt=&quot;AWS Console &amp;gt; VPC &amp;gt; VPC 생성1&quot; /&gt;&lt;em&gt;이미지 6. VPC 생성 버튼 클릭&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lambda-nat/create_vpc2.png&quot; alt=&quot;AWS Console &amp;gt; VPC &amp;gt; VPC 생성2&quot; /&gt;&lt;em&gt;이미지 7. VPC 생성&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. Amazon VPC에 하나의 퍼블릭 서브넷과 둘 이상의 프라이빗 서브넷을 생성합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AWS Console &amp;gt; VPC &amp;gt; Subnet 생성&lt;/li&gt;
  &lt;li&gt;이름 및 IPv4과 가용영역을 설정하고, 이전에 만든 VPC를 연결합니다.&lt;/li&gt;
  &lt;li&gt;Amazon VPC에 하나의 퍼블릭 서브넷과 둘 이상의 프라이빗 서브넷을 생성합니다.(서브넷을 생성할 때, [이름 태그]에 퍼블릭 또는 프라이빗 서브넷을 식별하는 각 서브넷의 이름을 입력합니다. 예: public-Subnet1, private-Lambda-Subnet1, private-Lambda-Subnet2)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lambda-nat/create_subnet1.png&quot; alt=&quot;AWS Console &amp;gt; VPC &amp;gt; Subnet 생성1&quot; /&gt;&lt;em&gt;이미지 8. 서브넷 생성 버튼 클릭&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lambda-nat/create_subnet2.png&quot; alt=&quot;AWS Console &amp;gt; VPC &amp;gt; Subnet 생성2&quot; /&gt;&lt;em&gt;이미지 9. 서브넷 생성&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 인터넷 게이트웨이를 생성하여 Amazon VPC에 연결합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AWS Console &amp;gt; VPC &amp;gt; IGW(Internet Gateway)&lt;/li&gt;
  &lt;li&gt;이름을 생성해준 후, 생성한 IGW를 클릭하여 이전 단계에서 만든 VPC에 연결해줍니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lambda-nat/create_igw1.png&quot; alt=&quot;AWS Console &amp;gt; VPC &amp;gt; IGW 생성1&quot; /&gt;&lt;em&gt;이미지 10. 인터넷 게이트웨이 생성 버튼 클릭&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lambda-nat/create_igw2.png&quot; alt=&quot;AWS Console &amp;gt; VPC &amp;gt; IGW 생성2&quot; /&gt;&lt;em&gt;이미지 11. 인터넷 게이트웨이 생성&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lambda-nat/create_igw3.png&quot; alt=&quot;AWS Console &amp;gt; VPC &amp;gt; IGW 연결&quot; /&gt;&lt;em&gt;이미지 12. 만들어둔 VPC연결&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. NAT 게이트웨이를 생성합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AWS Console &amp;gt; VPC &amp;gt; NAT GW(Network Address Translation Gateway)&lt;/li&gt;
  &lt;li&gt;이름을 설정하고 이전에 Public Subnet으로 사용하기 위해 만들었던 Subnet에 연결하여 NAT GW를 생성합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;✅ NAT Gateway는 시간당 &lt;strong&gt;0.059 USD&lt;/strong&gt;가 부과됩니다.(리전: 아시아 태평양(서울))&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lambda-nat/create_nat1.png&quot; alt=&quot;AWS Console &amp;gt; VPC &amp;gt; NAT GW 생성1&quot; /&gt;&lt;em&gt;이미지 13. NAT 게이트웨이 생성 버튼 클릭&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lambda-nat/create_nat2.png&quot; alt=&quot;AWS Console &amp;gt; VPC &amp;gt; NAT GW 생성2&quot; /&gt;&lt;em&gt;이미지 14. 만들어둔 서브넷 연결 후 NAT 게이트웨이 생성&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 퍼블릭 서브넷과 프라이빗 서브넷용 사용자 지정 라우팅 테이블 두 개를 생성합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;AWS Console &amp;gt; VPC &amp;gt; Routing Table&lt;/li&gt;
  &lt;li&gt;이름을 지정하고 이전에 만든 VPC에 연결합니다.&lt;/li&gt;
  &lt;li&gt;퍼블릭 서브넷과 프라이빗 서브넷용 사용자 지정 라우팅 테이블 두 개를 생성합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lambda-nat/create_route1.png&quot; alt=&quot;AWS Console &amp;gt; VPC &amp;gt; 라우팅 테이블 생성1&quot; /&gt;&lt;em&gt;이미지 15. 라우팅 테이블 생성 버튼 클릭&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lambda-nat/create_route2.png&quot; alt=&quot;AWS Console &amp;gt; VPC &amp;gt; 라우팅 테이블 생성2&quot; /&gt;&lt;em&gt;이미지 16. 라우팅 테이블 두 개 생성&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;🧩 퍼블릭 서브넷의 라우팅 테이블의 경우&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;[Destination]에 [0.0.0.0/0]을 입력합니다.&lt;/li&gt;
  &lt;li&gt;[Target]에서 IGW를 선택한 다음, 이전에 생성한 IGW의 ID(my-igw1)를 선택합니다.&lt;/li&gt;
  &lt;li&gt;서브넷 연결 &amp;gt; 서브넷 연결 편집 &amp;gt; Public Subnet 선택 &amp;gt; 저장합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lambda-nat/create_route3.png&quot; alt=&quot;AWS Console &amp;gt; VPC &amp;gt; 라우팅 테이블 생성3&quot; /&gt;&lt;em&gt;이미지 17. 라우팅 테이블 편집에서 인터넷 게이트웨이 연결&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;🧩 프라이빗 서브넷의 라우팅 테이블의 경우&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;[Destination]에 [0.0.0.0/0]을 입력합니다.&lt;/li&gt;
  &lt;li&gt;[Target]에서 NAT GW 선택합니다. 그런 다음 생성한 NAT GW(my-nat-gw1)의 ID를 선택합니다.&lt;/li&gt;
  &lt;li&gt;서브넷 연결 &amp;gt; 서브넷 연결 편집 &amp;gt; Private Subnet들 선택 &amp;gt; 저장합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lambda-nat/create_route4.png&quot; alt=&quot;AWS Console &amp;gt; VPC &amp;gt; 라우팅 테이블 생성4&quot; /&gt;&lt;em&gt;이미지 18. 라우팅 테이블 편집에서 NAT 게이트웨이 연결&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-lambda-함수-구성&quot;&gt;📘 Lambda 함수 구성&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Lambda 콘솔에서 함수페이지를 연 후, 본인이 생성한 Amazon VPC에 연결할 함수를 선택합니다.&lt;/li&gt;
  &lt;li&gt;[구성] &amp;gt; VPC &amp;gt; [편집]을 선택합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lambda-nat/lambda1.png&quot; alt=&quot;AWS Console &amp;gt; Lambda &amp;gt; VPC 연결할 함수 &amp;gt; 구성 &amp;gt; VPC &amp;gt; 편집&quot; /&gt;&lt;em&gt;이미지 19. Lambda 함수 VPC 편집 선택&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;VPC를 선택한 후, 만들어 둔 Private Subnet을 선택합니다.&lt;/li&gt;
  &lt;li&gt;[보안 그룹]에서 보안 그룹을 선택합니다.(참고 : &lt;a href=&quot;https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html#DefaultSecurityGroup&quot;&gt;기본 보안 그룹&lt;/a&gt;을 사용해도 모든 아웃바운드 인터넷 트래픽을 허용하며, 대부분의 경우에 충분합니다. 자세한 내용은 &lt;a href=&quot;https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html&quot;&gt;VPC의 보안 그룹&lt;/a&gt;을 참조하십시오. &lt;span style=&quot;color:gray; font-size:2px;&quot;&gt;- 출처: AWS Docs&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lambda-nat/lambda2.png&quot; alt=&quot;Lambda VPC 편집&quot; /&gt;&lt;em&gt;이미지 20. VPC 편집&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;끝맺음&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;VPC, NAT GW, IGW 등에 대해 다시 정리를 해보려다 직접 연결을 해보면서 하는 것이 나을 것 같아서, 예시로 Lambda에 연결하는 부분까지 다시 정리해 보았습니다. 내용을 정리하면서 여러 정보를 찾았는데, 결론은 다들 요금 주의,,,,,,😭 NAT GW에서 쓸데없는 요금이 나가는 경우도 있더라고요. 다음에는 AWS를 하면서 주의해야 할 요금에 대해 정리를 해보려 합니다.(솔직히 아직 AWS에 대해 초보이다 보니, 이번에 강전희 님과 정태환 님이 번역하신 &lt;a href=&quot;http://www.yes24.com/Product/Goods/111715522&quot;&gt;AWS 비용 최적화 바이블 - 핀옵스를 위한 최적의 기술 활용부터 운영 노하우까지&lt;/a&gt;를 샀습니다…. 빨리 다 읽어보고 한번 정리를 해보려고 합니다!😃)&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[참고자료]&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/vpc/latest/userguide/working-with-vpcs.html#AddaSubnet&quot;&gt;AWS docs - VPC, Subnet&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/premiumsupport/knowledge-center/internet-access-lambda-function/&quot;&gt;https://aws.amazon.com/ko/premiumsupport/knowledge-center/internet-access-lambda-function/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@kimjnsjwj/vpc내의-aws-lambda의-인터넷-접속-bc503e9940f5&quot;&gt;https://medium.com/@kimjnsjwj/vpc내의-aws-lambda의-인터넷-접속-bc503e9940f5&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jbhs7014.tistory.com/164&quot;&gt;https://jbhs7014.tistory.com/164&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://err-bzz.oopy.io/c4abbed2-fc30-4061-81b0-2803c4a59809&quot;&gt;https://err-bzz.oopy.io/c4abbed2-fc30-4061-81b0-2803c4a59809&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/vpc/latest/userguide/VPC_SecurityGroups.html&quot;&gt;AWS docs - VPC의 보안 그룹&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 19 Aug 2022 21:01:55 +0900</pubDate>
        <link>http://localhost:4000/lambda-nat/</link>
        <guid isPermaLink="true">http://localhost:4000/lambda-nat/</guid>
        
        
        <category>AWS</category>
        
        <category>AWS Lambda</category>
        
      </item>
    
      <item>
        <title>신입 백앤드 개발자(나)를 위한 면접 질문 정리 - 기타(공통, 인프라/클라우드(AWS), 컨테이너)</title>
        <description>&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-intro&quot;&gt;💡 Intro&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;신입 백앤드 개발자를 위한 면접 질문 정리 - 기타(공통, 인프라/클라우드(AWS), 컨테이너)&lt;/strong&gt; 에서는 프로그래밍 공통 질문과 트러블 슈팅, 인프라/클라우드, 컨테이너 등에 대한 면접 질문을 다루어 보려고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-개발-면접-질문---공통&quot;&gt;🔎 개발 면접 질문 - 공통&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1-devops란-무엇인가요&quot;&gt;1. DevOps란 무엇인가요?&lt;/h4&gt;

&lt;p&gt;데브옵스(Dev(개발) Ops(운영))란, 애플리케이션 개발-운영 간의 협업 프로세스를 자동화하는 것을 말하는 개발 방법론 이며, 결과적으로 애플리케이션의 개발과 개선 속도를 빠르게 합니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;과거 새로운 서비스를 출시하기 위해서 오랜기간 작업 후 배포했던 것과 달리, 현재는 서비스 출시 속도가 다르고 업데이트 주기 또한 빈번해 졌습니다. 때문에 개발된 소프트웨어가 시스템의 안정성을 유지하면서 사용자에게 빠르게 제공될 수 있도록 업무 사이클을 자동화 시킬 수 있도록 하는 데브옵스와 같은 개발 방법론이 등장 했습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-cicd란-무엇인가요-적용해-본-적이있다면-설명해-주세요&quot;&gt;2. CI/CD란 무엇인가요? 적용해 본 적이있다면 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;CI(Continuous Integration)/CD(Continuous Deployment)란, 서비스 빌드부터 배포까지 애플리케이션 개발 단계를 자동화 하는 과정입니다. 예를 들어 Github으로 코드를 커밋하고 Jenkins가 자동으로 빌드하도록 설계해본 경험 등에 대해 설명하면 될 것 같습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;CI/CD에 대한 경험이 부족하거나 깊이 있게 공부하고 싶으면 🌎&lt;a href=&quot;https://tecoble.techcourse.co.kr/post/2021-08-14-ci-cd/&quot;&gt;CI/CD가 뭔가요? 이론편&lt;/a&gt;과, 🌎&lt;a href=&quot;https://tecoble.techcourse.co.kr/post/2021-10-10-jenkins/&quot;&gt;CI/CD가 뭔가요? 실전편&lt;/a&gt;에서 자세하게 다루어 볼 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-test-code에-대해서-알고-계신가요-그렇다면-왜-작성해야-할까요&quot;&gt;3. Test Code에 대해서 알고 계신가요? 그렇다면 왜 작성해야 할까요?&lt;/h4&gt;

&lt;p&gt;테스트 코드란 내가 작성한 메서드가 실제로 제대로 동작하는지에 대해 테스트를 하는 코드입니다. 테스트 코드는 잘 작동하고, 깔끔한 코드를 얻기 위해서 작성합니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;필자의 예시 : 저는 테스트 코드에 대해 잘 알지 못할 때 코드를 배포하기 전, &lt;strong&gt;&lt;em&gt;코드 수정 -&amp;gt; 서버동작 -&amp;gt; 테스트에 필요한 데이터를 DB에 입력 -&amp;gt; 테스트 -&amp;gt; DB 데이터 정리 -&amp;gt; 과정 반복&lt;/em&gt;&lt;/strong&gt;등의 단계를 겪었습니다. 그 후 테스트 코드를 알고 나서 &lt;strong&gt;&lt;em&gt;코드 수정 -&amp;gt; 테스트 코드 실행 -&amp;gt; 결과 확인&lt;/em&gt;&lt;/strong&gt; 정도로 많은 시간을 절약할 수 있었습니다. 이러한 테스트 코드의 장점은 시간절약, 문서로서의 역할 가능(보통 값이 주어짐(given), 무엇을 했을 때(when) 어떤 값을 원함(then)의 구조이기 때문에 가독성이 뛰어남), 깔끔한 인터페이스등이 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-tddtest-driven-development에-대해-설명해-주세요&quot;&gt;4. TDD(Test-Driven Development)에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;TDD란 작은 단위의 테스트 케이스를 작성하고 그에 맞는 코드를 작성하여 테스트를 통과한 후에 상황에 맞게 리팩토링하는 테스트 주도 개발 방식을 말합니다. 레드 그린 사이클이라는 3가지 과정을 거치는데,&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;Red&lt;span&gt; - 항상 실패하는 테스트를 먼저 작성하고,&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;&lt;span style=&quot;color:green&quot;&gt;Green&lt;span&gt; - 테스트가 통과하는 프로덕션 코드를 작성한 후,&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
  &lt;li&gt;Refactor - 작성한 프로덕션 코드를 깨끗하고 가독성 좋게 리펙토링합니다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;5-ddddomain-driven-design에-대해-설명해-주세요&quot;&gt;5. DDD(Domain-Driven Design)에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;DDD란, 각 비즈니스 도메인이 중심이 되어 진행하는 개발 방식으로 소프트웨어의 연관된 부분들을 연결하여 계속해서 진화하는 새로운 모델을 만들어나가 복잡한 애플리케이션을 만드는 것을 쉽게 해주는 것에 있습니다. 도메인 전문가와 IT 개발자 간의 커뮤니케이션과 협업을 통해서 모델을 발전시키는 것을 추구합니다. 쇼핑몰을 예로 들면 손님들이 주문하는 도메인, 점주들이 관리하는 도메인 등이 있을 수 있습니다. 이러한 도메인들이 서로 상호작용하며 설계하는 것이 도메인 주도 설계입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/interview/ddd.png&quot; alt=&quot;DDD(Domain-Driven Design)&quot; /&gt;&lt;em&gt;이미지 1. DDD(Domain-Driven Design)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;6-monolithic-architecture와-msamicroservice-architecture의-차이점에-대해-설명해-주세요&quot;&gt;6. &lt;u&gt;Monolithic Architecture&lt;/u&gt;와 &lt;u&gt;MSA(Microservice Architecture)&lt;/u&gt;의 차이점에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;모놀리식 아키텍쳐는 모든 시스템의 구성요소가 한 프로젝트에 통합되어 있는 하나의 통합된 패키지로 개발하는 방식입니다. 반면에, 마이크로 서비스는 1개의 시스템을 독립적으로 배포가능한 각각의 서비스로 분할하는 개별 서비스 단위로 개발하는 방식입니다. 때문에 마이크로 서비스는 개별 서비스 단위로 나뉘어져 있어서 해당 부분만 수정 또는 배포하기 좋고, 필요한 부분만 확장하기에도 용이하다는 장점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/interview/msa.png&quot; alt=&quot;MSA(Microservice Architecture)&quot; /&gt;&lt;em&gt;이미지 2. MSA(Microservice Architecture)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;7-트러블슈팅troubleshooting을-경험해-보셨나요&quot;&gt;7. 트러블슈팅(troubleshooting)을 경험해 보셨나요?&lt;/h4&gt;

&lt;p&gt;개발을 하면서 발생한 문제를 어떻게 해결했는지, 원인 규명 -&amp;gt; 사실 정리 -&amp;gt; 원인 추론 -&amp;gt; 조치 및 방안 검토 -&amp;gt; 해결 과정을 차근차근 설명하시면 될 것같습니다. 추가로 알게 된 개념 혹은 방법을 곁들여서 함께 설명할 수 있으면 더 좋을 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-개발-면접-질문---컨테이너&quot;&gt;🔎 개발 면접 질문 - 컨테이너&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1-docker에-대해-설명해-주세요&quot;&gt;1. Docker에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;도커는 컨테이너 기술을 기반으로한 가상화 플랫폼입니다. 기존의 가상화는 하드웨어를 가상화하여 무거운데다, 반드시 하이퍼바이저를 거쳐야 하기 때문에 속도 저하가 발생했습니다. 이러한 이유로 베이스 환경의 OS를 공유하면서 필요한 프로세스만 격리시킨 컨테이너를 통해 가상화를 하는 Docker같은 기술이 등장했습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/interview/docker.png&quot; alt=&quot;Docker&quot; /&gt;&lt;em&gt;이미지 3. VM과 Docker의 차이&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;가상 머신을 생성하기 위해서는 하이퍼바이저 또는 가상 머신 모니터라고 불리는 소프트웨어를 이용합니다. &lt;strong&gt;하이퍼바이저는 호스트 하드웨어에 설치되어 호스트와 게스트를 나누는 역할을 하고, 각각의 게스트는 하이퍼바이저에 의해 관리되며 시스템 자원을 할당받게 됩니다.&lt;/strong&gt; 하이퍼바이저와 달리 컨테이너는 가상의 OS를 만드는 것이 아닙니다. &lt;strong&gt;컨테이너는 베이스 환경의 OS를 공유하면서 필요한 프로세스만 격리하는 방식으로, 커널을 공유하기 때문에 호스트 OS의 기능을 모두 사용할 수 있습니다.&lt;/strong&gt; 그렇기 때문에 컨테이너 위에서는 호스트 OS와 다른 OS를 구동할 수 없습니다. 대신 격리시킬 애플리케이션과 거기에 필요한 파일이나 특정 라이브러리 등 종속 항목만 포함하기 때문에 배포를 위해 생성되는 이미지의 용량이 작아진다는 장점이 있습니다. 운영체제가 아닌 프로세스이며, 하이퍼바이저를 거칠 필요가 없어 실행 속도가 빠르기도 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-dockerfile-docker-compose-docker-image와-container의-차이-docker-hub&quot;&gt;2. Dockerfile, Docker-Compose, Docker Image와 Container의 차이, Docker Hub&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;Dockerfile : Dockerfile은 이미지를 생성하기 위한 용도로 컨테이너에 설치해야하는 패키지, 소스코드, 명령어, 환경변수설정 등을 기록한 하나의 파일&lt;/li&gt;
  &lt;li&gt;Docker-Compose : 여러 컨테이너들을 한 번에 관리를 할 수있게 도와주는 파일&lt;/li&gt;
  &lt;li&gt;Docker Image와 Container의 차이 : 서비스 운영에 필요한 서버 프로그램, 소스코드 및 라이브러리, 컴파일된 실행 파일을 묶은 것을 Docker image라 하며, Image를 실행한 상태를 Container라고 함&lt;/li&gt;
  &lt;li&gt;Docker Hub : Docker에서 운영하는 Docker 이미지 저장소 서비스&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;3-k8skubernetes에-대해서-설명해-주세요&quot;&gt;3. k8s(Kubernetes)에 대해서 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;쿠버네티스(Kubernetes)란, 컨테이너화된 애플리케이션의 배포, 확장 및 관리를 자동화하는 오픈 소스 시스템입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-1-쿠버네티스-클러스터의-기본-아키텍처에-대해-설명해-주세요&quot;&gt;3-1. 쿠버네티스 클러스터의 기본 아키텍처에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-2-쿠버네티스에서-auto-scaling의-원리에-대해-설명해-주세요&quot;&gt;3-2. 쿠버네티스에서 Auto Scaling의 원리에 대해 설명해 주세요.&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;아직 k8s에 대해 익숙하지 않아서 열심히 공부하는 중입니다;ㅅ;. 🌎&lt;a href=&quot;https://kubernetes.io/ko/docs/home/&quot;&gt;kubernetes 공식 문서&lt;/a&gt;에서 깊이 있게 공부하실 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-개발-면접-질문---인프라클라우드&quot;&gt;🔎 개발 면접 질문 - 인프라/클라우드&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1-aws-인프라를-구축해본-경험에-대해-설명해-주세요&quot;&gt;1. AWS 인프라를 구축해본 경험에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;AWS를 사용해본 경험에 대하여 설명해 주시면 될 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-서버리스serverless란-무엇인가요&quot;&gt;2. 서버리스(Serverless)란 무엇인가요?&lt;/h4&gt;

&lt;p&gt;서버리스 컴퓨팅(Serverless Computing)이란 IT 인프라를 데이터센터 또는 클라우드에 준비 없이 필요한 기능을 함수로 구현해서 관리하는 것을 의미 합니다. 추가로 서버리스 컴퓨팅을 사용해본 경험에 대해 질문이 들어온다면, AWS Lambda와 같은 서버리스 컴퓨팅 플랫폼을 사용해본 경험에 대해 설명하시면 될 것 같습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;서버리스 컴퓨팅은 IT 인프라를 데이터센터 또는 클라우드에 준비 없이, 필요한 기능을 함수(Function) 형태로 구현하고, 자동 스케일링 방식으로 시시각각 변하는 자원 수요를 지원하며 전통적인 백엔드를 대신합니다. 따라서 서버리스 컴퓨팅을 &lt;strong&gt;FaaS(Function as a Service)&lt;/strong&gt; 라고도 하고 백엔드 시스템을 보이지 않는 서비스로 추상화하였기 때문에 &lt;strong&gt;BaaS(Backend as a Service)&lt;/strong&gt; 라고도 합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/interview/serverless.png&quot; alt=&quot;서버리스 컴퓨팅&quot; /&gt;&lt;em&gt;이미지 4. 기술의 발전&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-amazon-vpcamazon-virtual-private-cloud란-무엇인가요&quot;&gt;3. Amazon VPC(Amazon Virtual Private Cloud)란 무엇인가요?&lt;/h4&gt;

&lt;p&gt;AWS 클라우드에서 다른 고객과 완벽하게 논리적으로 격리된 네트워크 공간을 제공하여 프로비저닝하여 가상 네트워크에서 AWS 리소스를 만드는데 사용하는 리소스입니다. 쉽게 풀어서 설명하자면, 자신이 사용할 AWS Resource들을 격리 되어진 하나의 네트워크로 묶는 서비스를 의미하며 격리되어 있기 때문에 다른 사람들은 접근하고 보는 것이 불가능해집니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;만약, VPC 없이 인스턴스를 생성한다면 인스턴스끼리의 구분없는 연결로 인해 시스템 복잡도가 증가할 것이며, 인터넷을 통해 전달되는 트래픽의 전송이 굉장히 비효율적이게 될 것 입니다. VPC를 적용하면 인스턴스가 VPC에 속함으로써 네트워크를 구분할 수 있고, VPC 별로 필요한 설정을 통해 인스턴스에 네트워크 설정을 적용할 수 있습니다. AWS는 VPC의 중요성을 강조하여 2019년부터 거의 모든 서비스에 VPC를 적용하도록 강제하였습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-1-amazon-vpc에-따른-aws-lambda의-상태에-대해-설명해주세요&quot;&gt;3-1. Amazon VPC에 따른 AWS Lambda의 상태에 대해 설명해주세요.&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;VPC&lt;/strong&gt;가 없는 상태 : 웹에 자유롭게 접속할 수 있지만, 로컬 네트워크로 AWS 서비스들과 연결할 수 없습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;VPC&lt;/strong&gt;가 있는 상태 : 기본적인 설정으로 로컬 네트워크에 연결이 가능하지만, 웹에는 접속할 수 없습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;VPC&lt;/strong&gt;와 &lt;strong&gt;NAT&lt;/strong&gt;이 있는 상태 : AWS 서비스와 웹 둘 다 접속이 가능합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-2-natnetwork-address-translation-네트워크-주소-변환-gateway란-무엇인가요&quot;&gt;3-2. NAT(Network Address Translation, 네트워크 주소 변환) Gateway란 무엇인가요?&lt;/h4&gt;

&lt;p&gt;NAT(Network Address Translation, 네트워크 주소 변환) Gateway란, 외부 서비스에서 프라이빗 서브넷의 인스턴스로 접근할 수 없게 하되, 프라이빗 서브넷의 인스턴스에서는 외부 서비스로 접근할 수 있게 해주는 서비스 입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/interview/natgateway.png&quot; alt=&quot;NAT GW&quot; /&gt;&lt;em&gt;이미지 5. NAT GW (Network Address Translation Gateway)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-만약-클라이언트의-수가-늘어나게-되면서-기존-서버만으로는-정상적인-서비스가-불가능하게-되었습니다-이럴-때는-어떠한-방법이-있을까요&quot;&gt;4. 만약 클라이언트의 수가 늘어나게 되면서 기존 서버만으로는 정상적인 서비스가 불가능하게 되었습니다. 이럴 때는 어떠한 방법이 있을까요?&lt;/h4&gt;

&lt;p&gt;증가한 트래픽에 대처할 수 있는 방법은 크게 서버 자체의 성능을 확장하는 Scale-up 방식과 서버를 여러대로 나눠서 트래픽을 처리하는 Scale-out의 방법이 있습니다. 또한, Scale-out의 방식은 여러 대의 서버로 트래픽을 균등하게 분산해주는 로드밸런싱이 반드시 필요합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-1-로드-밸런서load-balancer에-대해서-설명해-주세요&quot;&gt;4-1. 로드 밸런서(Load Balancer)에 대해서 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;로드 밸런서란, 서버에 가해지는 트래픽을 여러 대의 서버에게 균등하게 분산시켜주는 역할을 합니다. 또한, 여러 대의 서버 덕분에 무중단 서비스 제공할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;로드 밸런싱의 종류와 알고리즘, 장애 대비 및 ELB(Elastic Load Balancer), ALB(Application Load Balancer), NLB(Network Load Balancer)에 대해서 미리 공부하고 가시는 것을 추천드립니다. 🌎&lt;a href=&quot;https://yoo11052.tistory.com/63&quot;&gt;[AWS] 로드 밸런서란?&lt;/a&gt;, &lt;a href=&quot;https://nesoy.github.io/articles/2018-06/Load-Balancer&quot;&gt;Load Balancer 장애 대비&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;5-무중단-시스템으로-가기-위해-필요한-방법에-대한-본인의-생각을-말해주세요&quot;&gt;5. 무중단 시스템으로 가기 위해 필요한 방법에 대한 본인의 생각을 말해주세요.&lt;/h4&gt;

&lt;p&gt;다운 타임이 발생하지 않도록 기본적으로 두 대 이상의 서버를 서비스해야 합니다. 비용 절감을 위해 배포할 때에만 새롭게 서비스를 띄우고, 배포가 완료된 후에는 기존 서버는 셧다운 시키면 될 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;6-forward-proxy와-reverse-proxy에-대해-설명해-주세요&quot;&gt;6. &lt;u&gt;Forward Proxy&lt;/u&gt;와 &lt;u&gt;Reverse Proxy&lt;/u&gt;에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;Forward Proxy&lt;/strong&gt; : 클라이언트에서 서버로 리소스를 요청할 때 직접 요청하지 않고 프록시 서버를 거쳐서 요청합니다. 특정 컨텐츠에 접근하는 것을 방지할 수 있으며, 유저의 정체를 숨겨줄 수도 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/interview/forward.png&quot; alt=&quot;Forward Proxy&quot; /&gt;&lt;em&gt;이미지 6. Forward Proxy&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Reverse Proxy&lt;/strong&gt; : 애플리케이션 서버의 앞에 위치하여 클라이언트가 서버를 요청할 때 리버스 프록시를 호출하고, 리버스 프록시가 서버로부터 응답을 전달받아 다시 클라이언트에게 전송하는 역할을 합니다. 로드 밸런싱(load balancing)에 사용되고 있으며, SSL 암호화와 보안에 좋다는 장점이 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;NginX, Apache Web Server 등의 오픈 소스 소프트웨어에서 지원하고 CloudFlare, AWS CloudFront 같은 CDN 서비스도 마찬가지로 리버스 프록시 서버를 사용하고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/interview/reverse.png&quot; alt=&quot;Reverse Proxy&quot; /&gt;&lt;em&gt;이미지 7. Reverse Proxy&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;7-aws-리전region과-가용-영역availability-zone-az에-대해-설명해-주세요&quot;&gt;7. AWS 리전(Region)과 가용 영역(Availability Zone, AZ)에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;8-snapshot에-대해-설명해-주세요&quot;&gt;8. Snapshot에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;8-1-ec2-amiamazon-machine-image와-snapshot의-차이점에-대해-설명해-주세요&quot;&gt;8-1. &lt;u&gt;EC2 AMI(Amazon Machine Image)&lt;/u&gt;와 &lt;u&gt;Snapshot&lt;/u&gt;의 차이점에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;기본적으로 EBS(Elastic Block Store)를 백업한다는 점에서는 AMI(Amazon Machine Image)와 Snapshot은 동일하지만, AMI는 EC2 인스턴스에 연결되어 있는 모든 EBS Volume을 동시에 백업하는 것이라면 Snapshot 기능은 여러분들이 선택한 EBS Volume을 백업한다는 점에서 차이점이 있습니다. 또한 Snapshot은 AMI 주기적인 백업 기능을 제공해주지만, AMI는 제공하지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;끝맺음&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;공부를 하면서 질문에 괜찮은 내용이 있으면 요약하면서 계속 추가하고 있습니다. 또한, 기본적인 이론에 대해 다시 공부를 하려고 정리한 내용이기 때문에 잘못된 부분들이 있을 수도 있습니다. 잘못된 정보가 보이거나, 부족한 내용, 추가되면 좋을 것 같은 내용이 있다면 댓글에 적어주시면 감사하겠습니다!😊&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[참고자료]&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://tecoble.techcourse.co.kr/post/2021-10-10-jenkins/&quot;&gt;CI/CD가 뭔가요? 실전편&lt;/a&gt;, &lt;a href=&quot;https://tecoble.techcourse.co.kr/post/2021-08-14-ci-cd/&quot;&gt;CI/CD가 뭔가요? 이론편&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://steemit.com/kr/@frontalnh/domain-driven-design&quot;&gt;Domain Driven Design 이란 무엇인가?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kubernetes.io/ko/docs/home/&quot;&gt;https://kubernetes.io/ko/docs/home/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://yoo11052.tistory.com/63&quot;&gt;[AWS] 로드 밸런서란?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://losskatsu.github.io/it-infra/reverse-proxy/#&quot;&gt;[Infra] 리버스 프록시(reverse proxy) 서버 개념&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/what-is-amazon-vpc.html&quot;&gt;https://docs.aws.amazon.com/ko_kr/vpc/latest/userguide/what-is-amazon-vpc.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/premiumsupport/knowledge-center/internet-access-lambda-function/&quot;&gt;https://aws.amazon.com/ko/premiumsupport/knowledge-center/internet-access-lambda-function/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://cloudguardians.medium.com/ec2-ami-%EC%99%80-snapshot-%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90-db8dc5682eac&quot;&gt;JIPA님 블로그&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.slideshare.net/ssuserd4f9ff/aws-devops-ecr-elastic-beanstalk-240070104&quot;&gt;WS DevOps와 ECR을 통한 Elastic Beanstalk 배포 환경 구축 및 타 환경과의 비교&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 13 Aug 2022 18:55:46 +0900</pubDate>
        <link>http://localhost:4000/interview3/</link>
        <guid isPermaLink="true">http://localhost:4000/interview3/</guid>
        
        
        <category>Interview</category>
        
        <category>AWS</category>
        
        <category>Docker</category>
        
        <category>K8S</category>
        
      </item>
    
      <item>
        <title>신입 백앤드 개발자(나)를 위한 면접 질문 정리 - 데이터베이스</title>
        <description>&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-intro&quot;&gt;💡 Intro&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;신입 백앤드 개발자를 위한 면접 질문 정리 - 데이터베이스&lt;/strong&gt;에서는 데이터베이스에 대한 전반적인 면접 질문을 다루어 보려고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-개발-면접-질문---데이터베이스&quot;&gt;🔎 개발 면접 질문 - 데이터베이스&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1-sql-select-쿼리-문법-순서와-실행-순서에-대해서-설명해-주세요&quot;&gt;1. SQL SELECT 쿼리 문법 순서와 실행 순서에 대해서 설명해 주세요.&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;SQL 문법 순서 : SELECT -&amp;gt; FROM -&amp;gt; WHERE -&amp;gt; GROUP BY -&amp;gt; HAVING -&amp;gt; ORDER BY&lt;/li&gt;
  &lt;li&gt;SQL 실제 실행 순서 : FROM(각 테이블 확인) -&amp;gt; ON(조인 조건 확인) -&amp;gt; JOIN(테이블 조인(병합)) -&amp;gt; WHERE(데이터 추출 조건 확인) -&amp;gt; GROUP BY(특정 칼럼으로 데이터 그룹화) -&amp;gt; HAVING(그룹화 이후 데이터 추출 조건 확인) -&amp;gt; SELECT(데이터 추출) -&amp;gt; DISTINCT(중복 제거) -&amp;gt; ORDER BY(데이터 정렬) -&amp;gt; LIMIT&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-데이터베이스에서-인덱스를-사용하는-이유와-장점-단점에-대해서-설명해-주세요&quot;&gt;2. 데이터베이스에서 인덱스를 사용하는 이유와 장점, 단점에 대해서 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;인덱스란, 테이블을 처음부터 끝까지 검색하는 방법인 FTS(Full Table Scan)과는 달리 인덱스를 검색하여 해당 자료의 테이블을 엑세스하는 방법입니다. 즉, 인덱스를 잘 사용하면 데이터베이스의 테이블에서 필요한 데이터를 빨리 찾을 수 있다는 장점이 있습니다. 인덱스의 단점이라하면 추가, 수정, 삭제 연산시에는 인덱스를 형성하기 위한 추가적인 연산이 수행되기 때문에 실행 속도가 느릴 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-rdbms와-nosql에-대해서-설명한-후-그-두-가지의-차이점에-대해서-설명해-주세요&quot;&gt;3. &lt;u&gt;RDBMS&lt;/u&gt;와 &lt;u&gt;NoSQL&lt;/u&gt;에 대해서 설명한 후 그 두 가지의 차이점에 대해서 설명해 주세요.&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;RDBMS는 데이터베이스를 이루는 객체들의 릴레이션을 통해서 데이터를 저장하는 데이터베이스입니다.&lt;/li&gt;
  &lt;li&gt;NOSQL은 RDBMS에 비해 자유로운 형태로 데이터를 저장합니다. 또한 수평확장을 할 수 있고 분산처리를 지원합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RDBMS와 NoSQL의 가장 큰 차이점은 RDBMS는 정해진 스키마가 존재하지만, NoSQL은 정해진 스키마가 없다는 것입니다. NoSQL은 정해진 스키마가 없을 때 데이터 구조 변화가 자유롭고 데이터 분산이 용이하다는 장점이 있지만, 데이터 중복 또는 변경시에 연산이 오래걸릴 수 있다는 단점이 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-트랜잭션에-대해서-설명해-주세요&quot;&gt;4. 트랜잭션에 대해서 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;트랜잭션이란 데이터베이스의 상태를 변화시키는 하나의 논리적인 작업 단위라고 할 수 있으며, 작업의 완전성을 보장해 줍니다. 즉, 작업들을 모두 처리하거나 처리하지 못할 경우 이전 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않게 해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-1-트랜잭션의-acid에-대해서-설명해-주세요&quot;&gt;4-1. 트랜잭션의 ACID에 대해서 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;ACID는 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Atomicity(원자성) : 트랜잭션의 연산은 모든 연산이 완벽히 수행되어야 하며, 한 연산이라도 실패하면 트랜잭션은 실패해야 합니다.&lt;/li&gt;
  &lt;li&gt;Consistency(일관성) : 트랜잭션을 수행하기 전이나 후나 데이터베이스는 항상 일관된 상태를 유지해야 합니다.&lt;/li&gt;
  &lt;li&gt;Isolation(고립성) : 트랜잭션은 동시에 실행될 경우 다른 트랜잭션에 의해 영향을 받지 않고 독립적으로 실행되어야 합니다.&lt;/li&gt;
  &lt;li&gt;Durability(지속성) : 트랜잭션이 완료된 이후에는 시스템 오류가 발생하더라도 완료된 상태로 영구히 저장되는 것을 보장해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-2-트랜잭션-격리-수준transaction-isolation-levels에-대해서-설명해-주세요&quot;&gt;4-2. 트랜잭션 격리 수준(Transaction Isolation Levels)에 대해서 설명해 주세요.&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;READ UNCOMMITTED : 다른 트랜잭션에서 커밋되지 않은 내용도 참조할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;READ COMMITTED : 다른 트랜잭션에서 커밋된 내용만 참조할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;REPEATABLE READ : 트랜잭션에 진입하기 이전에 커밋된 내용만 참조할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;SERIALIZABLE : 트랜잭션에 진입하면 락을 걸어 다른 트랜잭션이 접근하지 못하도록 합니다.(성능이 매우 떨어질 수 있음)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;5-db-lock에-대해-설명해주세요&quot;&gt;5. DB Lock에 대해 설명해주세요.&lt;/h4&gt;

&lt;p&gt;DB Lock은 트랜잭션 처리의 순차성을 보장하기 위한 방법입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;공유락(LS, Shared Lock) : Read Lock라고도 하는 공유락은 트랜잭션이 읽기를 할 때 사용하는 락이며, 데이터를 읽기만 하기 때문에 같은 공유락 끼리는 동시에 접근이 가능합니다.&lt;/li&gt;
  &lt;li&gt;베타락(LX, Exclusive Lock) : Write Lock라고도 하는 베타락은 데이터를 변경할 때 사용하는 락입니다. 트랜잭션이 완료될 때까지 유지되며, 베타락이 끝나기 전까지 어떠한 접근도 허용하지 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;6-정규화에-대해서-설명해-주세요&quot;&gt;6. 정규화에 대해서 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;정규화는 데이터의 중복방지, 무결성을 충족시키기 위해 데이터베이스를 설계하는 것을 의미합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;제1정규형 : 모든 속성 값이 원자 값을 갖도록 분해합니다.&lt;/li&gt;
  &lt;li&gt;제2정규형 : 제1정규형을 만족하고, 기본키가 아닌 속성이 기본키에 완전 함수 종속이도록 분해합니다.(여기서 완전 함수 종속이란 기본키의 부분집합이 다른 값을 결정하지 않는 것을 의미합니다.)&lt;/li&gt;
  &lt;li&gt;제3정규형 : 제2정규형을 만족하고, 기본키가 아닌 속성이 기본키에 직접 종속(비이행적 종속)하도록 분해합니다.(여기서 이행적 종속이란 A-&amp;gt;B-&amp;gt;C가 성립하는 것으로, 이를 A,B와 B,C로  분해하는 것이 제3정규형입니다.)&lt;/li&gt;
  &lt;li&gt;BCNF 정규형 : 제3정규형을 만족하고, 함수 종속성 X-&amp;gt;Y가 성립할 때 모든 결정자 X가 후보키가 되도록 분해합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;7-이상-현상에-대해서-설명해-주세요&quot;&gt;7. 이상 현상에 대해서 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;이상 현상은 테이블을 설계할 때 잘못 설계하여 데이터를 삽입,삭제,수정할 때 생기는 논리적 오류를 말합니다. 이상 현상의 종류는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;삽입 이상 : 자료를 삽입할 때 특정 속성에 해당하는 값이 없어 NULL을 입력해야 하는 현상&lt;/li&gt;
  &lt;li&gt;수정 이상 : 중복된 데이터 중 일부만 수정되어 데이터 모순이 일어나는 현상&lt;/li&gt;
  &lt;li&gt;삭제 이상 : 어떤 정보를 삭제하면, 의도하지 않은 다른 정보까지 삭제되어버리는 현상&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;8-redis에-대해서-간단히-설명해-주세요&quot;&gt;8. Redis에 대해서 간단히 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;Redis는 key-value store NOSQL DB입니다. 싱글스레드로 동작하며 자료구조를 지원합니다. 그리고 다양한 용도로 사용될 수 있도록 다양한 기능을 지원합니다. 데이터의 스냅샷 혹은 AOF 로그를 통해 복구가 가능해서 어느정도 영속성도 보장됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;8-1-그렇다면-redis를-왜-사용하나요&quot;&gt;8-1. 그렇다면 Redis를 왜 사용하나요?&lt;/h4&gt;

&lt;p&gt;사용자가 늘어남에 따라 DB에 부하가 가해지기 시작합니다. 이 부하를 줄이기 위해 한 번 읽어온 데이터를 저장하고, 다시 요청하는 경우 빠르게 결과 값을 받을 수 있도록(캐싱) 하기 위해 Redis를 사용합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/interview/redis.png&quot; alt=&quot;Redis&quot; /&gt;&lt;em&gt;이미지 1. Redis&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;여기서 캐시가 Redis가 되며 look aside cache 기준으로 가장 먼저 캐시에 데이터가 있는지 확인하고, 데이터가 있으면 캐시 데이터 사용합니다. 데이터가 없으면 실제 DB데이터 사용한 후 DB데이터를 캐시에 저장합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;9-elasticsearch에-대해서-설명해-주세요&quot;&gt;9. Elasticsearch에 대해서 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;Apache Lucene(아파치 루씬) 기반의 java 오픈소스 분산 검색 엔진이며, 역색인(Inverted Index) 구조로 데이터를 저장해서, 전체 텍스트 검색시에 RDBMS에 비해 뛰어난 성능을 보장합니다. 또한, 데이터 저장소가 아니기 때문에 관계형 데이터베이스(RDBMS: mysql, oracle, mariadb)를 대체할 수 없습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;🌎&lt;a href=&quot;https://woongsin94.tistory.com/345&quot;&gt;역색인(Inverted Index)이란?&lt;/a&gt;&lt;/strong&gt; 주어진 키워드에 대해서 해당 키워드가 포함된 데이터의 위치를 추적해내는 것을 의미합니다. 쉽게 말해서 색인은 데이터베이스 내의 데이터들로부터 키워드를 뽑아내는 과정이라면, 역색인은 특정 키워드에 대해 요청(Request)이 들어왔을때 해당 키워드들을 포함하고 있는 데이터들을 찾아내는 것을 의미합니다. 색인(Index)을 책 맨 앞의 목차라고 한다면, 역색인(Inverted Index)은 책 맨 뒷 부분의 색인이라고 할 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;9-1-elasticsearch의-인덱스-구조와-rdbms의-인덱스-구조의-차이에-대해-설명해-주세요&quot;&gt;9-1. Elasticsearch의 인덱스 구조와 RDBMS의 인덱스 구조의 차이에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;Elasticsearch는 역색인(Inverted Index) 구조로 데이터를 저장합니다. 반면 RDBMS는 B-Tree와 그와 유사한 인덱스를 사용합니다. 데이터가 어디에 존재하는지, 또는 어떤 순서로 저장하는지의 차이라고 생각합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;9-2-elasticsearch의-키워드-검색과-rdbms의-like-검색의-차이에-대해-설명해-주세요&quot;&gt;9-2. Elasticsearch의 키워드 검색과 RDBMS의 LIKE 검색의 차이에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;RDBMS는 단순 텍스트매칭에 대한 검색만을 제공해 동의어나 유의어 같은 검색은 불가능합니다. 하지만 Elasticsearch는 동의어나 유의어를 활용한 검색이 가능하며, 비정형 데이터의 색인과 검색이 가능하고, 역색인(Inverted Index) 지원으로 매우 빠른 검색이 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;10-cap-이론과-eventual-consistency에-대해서-설명해-주세요&quot;&gt;10. &lt;u&gt;CAP 이론&lt;/u&gt;과, &lt;u&gt;Eventual Consistency&lt;/u&gt;에 대해서 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/interview/cap.png&quot; alt=&quot;CAP 이론&quot; /&gt;&lt;em&gt;이미지 2. CAP 이론&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;CAP 이론은 분산 환경에서 모두를 만족하는 시스템은 없다는 이론입니다. 즉, CAP 세 가지 속성을 모두 만족하는 부분은 존재하지 않으며, 오직 두 가지만 만족할 수 있다로 정리되는 이론입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Consitenty(일관성) : ACID의 일관성과는 약간 다릅니다. 모든 노드가 같은 시간에 같은 데이터를 보여줘야 한다는 것입니다.&lt;/li&gt;
  &lt;li&gt;Availability(가용성) : 모든 동작에 대한 응답이 리턴되어야 합니다.&lt;/li&gt;
  &lt;li&gt;Partition Tolerance(분할 내성) : 시스템 일부가 네트워크에서 연결이 끊기더라도 동작해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Eventual Consistency이란, Consistency를 보장해주지 못하기 때문에 나온 개념으로, Consistency를 완전히 보장하지는 않지만 결과적으로 언젠가는 Conssistency가 보장됨을 의미합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;CAP 이론은 허점이 있는데, 그 허점에 대한 내용과 CAP 이론으로 부족한 부분을 보완하기위해 나온 PACELC 이론은 🌎&lt;a href=&quot;https://ohjongsung.io/2019/05/01/cap-%EC%9D%B4%EB%A1%A0%EA%B3%BC-pacelc-%EC%9D%B4%EB%A1%A0&quot;&gt;CAP 이론과 PACELC 이론&lt;/a&gt;에서 자세한 내용을 다루어 볼 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;11-ormobject-relational-mapping에-대해서-설명해-주세요&quot;&gt;11. ORM(Object Relational Mapping)에 대해서 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;ORM(Object Relational Mapping)이란, 객체와 관계형 데이터베이스 매핑의 줄임말 입니다. 우리가 OOP(Object Oriented Programming)에서 쓰는 객체라는 개념을 구현한 클래스와
RDB(Relational DataBase)에서 쓰이는 데이터인 테이블을 매핑하는 것을 의미합니다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:gray&quot;&gt;※ 추가로, SQLAlchemy 혹은 Django ORM등 본인이 사용한 ORM을 예시로 들며 추가 설명을 해주면 좋을 것 같습니다.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;12-replciation과-clustering에-대해-설명해-주세요&quot;&gt;12. Replciation과 Clustering에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;🧩 리플리케이션(Replciation)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;여러 개의 DB를 권한에 따라 수직적인 구조(Master-Slave)로 구축하는 방식입니다.&lt;/li&gt;
  &lt;li&gt;비동기 방식으로 노드들 간의 데이터를 동기화합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;장점&lt;/strong&gt; : 비동기 방식으로 데이터가 동기화되어 지연 시간이 거의 없습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt; : 노드들 간의 데이터가 동기화되지 않아 일관성있는 데이터를 얻지 못할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;🧩 클러스터링(Clustering)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;여러 개의 DB를 수평적인 구조로 구축하여 Fail Over한 시스템을 구축하는 방식입니다.&lt;/li&gt;
  &lt;li&gt;동기 방식으로 노드들 간의 데이터를 동기화합니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;장점&lt;/strong&gt; : 1개의 노드가 죽어도 다른 노드가 살아 있어 시스템을 장애없이 운영할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;단점&lt;/strong&gt; : 여러 노드들 간의 데이터를 동기화하는 시간이 필요하므로 리플리케이션에 비해 쓰기 성능이 떨어집니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;13-데이터베이스-튜닝tuning과-방법에-대해서-설명해-주세요&quot;&gt;13. 데이터베이스 튜닝(Tuning)과 방법에 대해서 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;DB 튜닝이란 DB의 구조나, DB 자체, 운영체제 등을 조정하여 DB 시스템의 전체적인 성능을 개선하는 작업을 말합니다. 튜닝은 DB 설계 튜닝 → DBMS 튜닝 → SQL 튜닝 단계로 진행할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/interview/tuning.png&quot; alt=&quot;DB tuning&quot; /&gt;&lt;em&gt;표 1. DB tuning&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;14-elk-stack에-대해서-설명해-주세요&quot;&gt;14. ELK Stack에 대해서 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;ELK&lt;/strong&gt;는 분석 및 저장 기능을 담당하는 &lt;strong&gt;E&lt;/strong&gt;lasticSearch, 수집 기능을 하는 &lt;strong&gt;L&lt;/strong&gt;ogstash, 이를 시각화하는 도구인 &lt;strong&gt;K&lt;/strong&gt;ibana의 앞글자만 딴 단어이며, ELK는 접근성과 용이성이 좋아 최근 가장 핫한 Log 및 데이터 분석 도구입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Elasticsearch : ElasticSearch는 Lucene 기반으로 개발한 분산 검색엔진으로, Logstash를 통해 수신된 데이터를 저장소에 저장하는 역할을 담당합니다.(자세한 내용은, &lt;strong&gt;9번 문제&lt;/strong&gt;로 가주세요.😊)&lt;/li&gt;
  &lt;li&gt;Logstash : 오픈소스 서버측 데이터 처리 파이프라인으로, 다양한 소스에서 동시에 데이터를 수집하고 변환하여 stash 보관소로 보냅니다.&lt;/li&gt;
  &lt;li&gt;Kibana : 데이터 시각화 및 탐색 툴로 Elasticsearch 상의 데이터를 쉽게 다룰 수 있게 해줍니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;주로 묶어서 많이 사용하기 때문에 ELK라고 부르지만, 각각의 도구들 전부 확장성이 뛰어나기 때문에 다른 도구로 대체 혹은 제외가 가능합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;추가로, Logstash는 데이터 수집의 역할을 맡고 있으면서, 원하는 형태로의 데이터 입출력 변환 기능까지 맡고 있었기 때문에, 데이터의 수집(파일 추적 등의 여러 단일 목적 데이터 수집 제품들)만을 담당하는 경량화된 모듈 &lt;strong&gt;Beats&lt;/strong&gt;가 도입되었습니다. 그로 인해 기존의 &lt;strong&gt;ELK Stack&lt;/strong&gt;은 Beats가 포함되어 &lt;strong&gt;Elastic Stack&lt;/strong&gt;이 되었습니다. 따라서 &lt;strong&gt;Elastic Stack의 Data Flow&lt;/strong&gt;는 아래 이미지와 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/interview/elk.png&quot; alt=&quot;Elastic Stack의 Data Flow&quot; /&gt;&lt;em&gt;이미지 3. Elastic Stack의 Data Flow&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;끝맺음&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;공부를 하면서 질문에 괜찮은 내용이 있으면 요약하면서 계속 추가하고 있습니다. 또한, 기본적인 이론에 대해 다시 공부를 하려고 정리한 내용이기 때문에 잘못된 부분들이 있을 수도 있습니다. 잘못된 정보가 보이거나, 부족한 내용, 추가되면 좋을 것 같은 내용이 있다면 댓글에 적어주시면 감사하겠습니다!😊&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[참고자료]&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://smjeon.dev/etc/interview-question/&quot;&gt;https://smjeon.dev/etc/interview-question/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://velog.io/@minsgy/백엔드-개발자-면접학습내용&quot;&gt;minsgy-백엔드 개발자 [면접/학습내용]&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://yong0810.tistory.com/52&quot;&gt;redis란?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://jiseok-woo.tistory.com/3&quot;&gt;Elasticsearch가 빠르다는데..? inverted index?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 28 Jul 2022 16:32:48 +0900</pubDate>
        <link>http://localhost:4000/interview2/</link>
        <guid isPermaLink="true">http://localhost:4000/interview2/</guid>
        
        
        <category>Interview</category>
        
      </item>
    
      <item>
        <title>신입 백앤드 개발자(나)를 위한 면접 질문 정리 - 네트워크, 운영체제</title>
        <description>&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-intro&quot;&gt;💡 Intro&lt;/h2&gt;

&lt;p&gt;백앤드 개발자가 기본적으로 알아야 하는 개념을 다시 한번 정리할 겸 하여 백앤드 개발자를 준비하면서 받았던 면접 질문, 그동안 학습하였던 내용 그리고 예상 가능한 질문을 정리해 보았습니다. 기본적인 백앤드 개념, 서버와 시스템에 대한 이해도의 내용을 중점으로 하였습니다. 당연하게도 정리돼 있는 질문들에 대해 딥 한 질문들이 들어올 수 있으니 깊이 있게 공부하셔야 합니다. 또한 
‘이 정도 질문들에 스스로 대답할 수 있는 정도의 기본기를 내가 가지고 있구나’를 확인하는 방향으로 공부해도 좋을 것 같습니다.😊&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-개발-면접-질문---네트워크&quot;&gt;🔎 개발 면접 질문 - 네트워크&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1-http와-https에-대해-설명해-주세요&quot;&gt;1. &lt;u&gt;HTTP&lt;/u&gt;와 &lt;u&gt;HTTPS&lt;/u&gt;에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;HTTP(Hyper Text Transfer Protocol)이란 데이터를 주고 받기 위한 프로토콜이며, 서버/클라이언트 모델을 따릅니다. 또한 HTTP는 평문 데이터를 전송하는 프로토콜이기 때문에, HTTP로 중요한 정보를 주고 받으면 제 3자에 의해 조회될 수 있습니다. 이러한 문제를 해결하기 위해 HTTP에 암호화가 추가된 프로토콜이 HTTPS입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/interview/https.png&quot; alt=&quot;http / https&quot; /&gt;&lt;em&gt;이미지 1. HTTP와 HTTPS의 차이&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;공개키(인증서)로 암호화된 메세지는 개인키를 가지고 있어야만 복호화가 가능하기 때문에, 서버(기업)을 제외한 누구도 원본 데이터를 얻을 수 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-http-method에-대해-설명해-주세요&quot;&gt;2. HTTP Method에 대해 설명해 주세요.&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;GET, POST, PUT, DELETE가 있습니다.&lt;/li&gt;
  &lt;li&gt;GET은 클라이언트에서 서버로 어떠한 리소스로부터 정보를 요청하기 위해 사용되는 메소드입니다. 서버에서 어떤 데이터를 보여줄 때 값, 내용, 상태들을 바꾸지 않을 경우에 사용됩니다.또한, 데이터가 헤더에 추가되어 전송되므로 URL에 데이터가 노출되기 때문에, 보안적으로 중요한 데이터는 포함시켜서는 안됩니다.&lt;/li&gt;
  &lt;li&gt;POST는 리소스를 생성,업데이트하기 위해 서버에 데이터를 보내는 데 사용하는 메소드 입니다. 즉, 서버상의 데이터 값이나 상태를 바꿀 때 사용됩니다. 또한 GET과는 달리 데이터를 바디에 추가여 전송하기 때문에, 완잔하게 안전한 것은 아니지만 조금 더 안전합니다.&lt;/li&gt;
  &lt;li&gt;GET과 POST의 차이점으로는 GET요청은 캐시가 되며 멱등성이 보장되지만, POST요청은 캐시가 되지 않고 멱등성이 보장되지 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-http의-주요-상태코드에-대해-설명해-주세요&quot;&gt;3. HTTP의 주요 상태코드에 대해 설명해 주세요.&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;200 : OK, 요청이 성공적으로 처리되었습니다. 요청에 따른 응답을 반환합니다.&lt;/li&gt;
  &lt;li&gt;404 : 서버는 요청받은 리소스를 찾을 수 없습니다. 예를 들어, 브라우저에서는 알려지지 않은 URL을 의미합니다.&lt;/li&gt;
  &lt;li&gt;503 : 서버가 요청을 처리할 준비가 되지 않은것을 의미합니다. 일반적인 원인은 유지보수를 위해 작동이 중단되거나, 과부하가 걸린 서버일 경우 발생할 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;또한 1번 대 부터 5번 대 상태 코드의 대략적인 의미는 다음과 같습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1xx (정보) : 요청을 받았으며 프로세스가 계속 진행합니다.&lt;/li&gt;
  &lt;li&gt;2xx (성공) : 요청을 성공적으로 받았으며 인식했고 수용합니다.&lt;/li&gt;
  &lt;li&gt;3xx (리다이렉션) : 요청을 위한 추가 작업 조치가 필요합니다.&lt;/li&gt;
  &lt;li&gt;4xx (클라이언트 오류) : 요청의 문법이 잘못되었거나 요청을 처리할 수 없습니다.&lt;/li&gt;
  &lt;li&gt;5xx (서버 오류) : 서버가 명백히 유효한 요청에 대한 충족을 실패했습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-쿠키cookie와-세션session의-차이점에-대해-말해-주세요&quot;&gt;4. &lt;u&gt;쿠키(Cookie)&lt;/u&gt;와 &lt;u&gt;세션(Session)&lt;/u&gt;의 차이점에 대해 말해 주세요.&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;쿠키는 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일입니다. HTTP에서 클라이언트의 상태 정보를 PC에 저장했다가 필요시 정보를 참조하거나 재사용할 수 있습니다.&lt;/li&gt;
  &lt;li&gt;세션은 일정 시간동안 같은 사용자로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 유지시키는 기술입니다. 즉, 방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 그것을 세션이라고 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;5-httpswwwgooglecom에-접속할-때-생기는-과정에-대해-설명해-주세요웹-동작-방식-이해&quot;&gt;5. https://www.google.com/에 접속할 때 생기는 과정에 대해 설명해 주세요.(웹 동작 방식 이해)&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/interview/web-flow.png&quot; alt=&quot;Web flow&quot; /&gt;&lt;em&gt;이미지 2. 웹 동작 방식 이해&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;사용자가 브라우저에 URL(https://www.google.com/)을 입력&lt;/li&gt;
  &lt;li&gt;브라우저는 DNS를 통해 서버의 진짜 주소를 찾음&lt;/li&gt;
  &lt;li&gt;HTTP 프로토콜을 사용하여 HTTP 요청 메세지를 생성함&lt;/li&gt;
  &lt;li&gt;TCP/IP 연결을 통해 HTTP요청이 서버로 전송됨&lt;/li&gt;
  &lt;li&gt;서버는 HTTP 프로토콜을 활용해 HTTP 응답 메세지를 생성함&lt;/li&gt;
  &lt;li&gt;TCP/IP 연결을 통해 요청한 컴퓨터로 전송&lt;/li&gt;
  &lt;li&gt;도착한 HTTP 응답 메세지는 웹페이지 데이터로 변환되고, 웹 브라우저에 의해 출력되어 사용자가 볼 수 있게 됨&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;6-tcp와-udp의-차이를-설명해-주세요&quot;&gt;6. &lt;u&gt;TCP&lt;/u&gt;와 &lt;u&gt;UDP&lt;/u&gt;의 차이를 설명해 주세요.&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;TCP는 연결형 서비스로 3-way handshaking 과정을 통해 연결을 설정하기 때문에 높은 신뢰성을 보장하지만, 속도가 비교적 느리다는 단점이 있습니다.(1:1 통신방식)&lt;/li&gt;
  &lt;li&gt;UDP는 비연결형 서비스로 3-way handshaking을 사용하지 않기 때문에 신뢰성이 떨어지는 단점이 있지만, 데이터 수신 여부를 확인하지 않기 때문에 속도가 빠르다는 장점이 있습니다.(1:1 or 1:N or N:N 통신방식)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;6-1-그렇다면-3-way-handshake와-4-way-handshake를-설명해-주세요&quot;&gt;6-1. 그렇다면 &lt;u&gt;3 way-handshake&lt;/u&gt;와 &lt;u&gt;4 way-handshake&lt;/u&gt;를 설명해 주세요.&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;3 way-handshake란 TCP 네트워크에서 통신 하는 장치가 서로 연결이 잘 되었는지 확인하는 방법입니다. 송신자와 수신자는 총 3번에 걸쳐 데이터를 주고 받으며 통신이 가능한 상태인지 확인합니다.&lt;/li&gt;
  &lt;li&gt;4 way-handshake란 TCP 네트워크에서 통신 하는 장치의 연결을 해제하는 방법입니다. 송신자와 수신자는 총 4번에 걸쳐 데이터를 주고 받으며 연결을 끊습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;7-osi-7-layer와-각-계층에-대해-아는대로-설명해-주세요&quot;&gt;7. OSI 7 layer와 각 계층에 대해 아는대로 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/interview/osi7.png&quot; alt=&quot;OSI 7 layer&quot; /&gt;&lt;em&gt;이미지 3. OSI 7 layer&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;OSI7계층은 네트워크 통신을 구성하는 요소들 7개의 계층으로 표준화 한 것입니다. 이렇게 표준화하는 것의 장점은 통신이 일어나는 과정을 단계별로 파악할 수 있어, 문제가 발생하면 해당 문제를 해결하기 용이해집니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;7 계층(응용 계층) : 사용자에게 통신을 위한 서비스 제공. 인터페이스 역할&lt;/li&gt;
  &lt;li&gt;6 계층(표현 계층) : 데이터의 형식(Format)을 정의하는 계층 (코드 간의 번역을 담당)&lt;/li&gt;
  &lt;li&gt;5 계층(세션 계층) : 컴퓨터끼리 통신을 하기 위해 세션을 만드는 계층&lt;/li&gt;
  &lt;li&gt;4 계층(전송 계층) : 최종 수신 프로세스로 데이터의 전송을 담당하는 계층 (단위 :Segment) (ex. TCP, UDP)&lt;/li&gt;
  &lt;li&gt;3 계층(네트워크 계층) : 패킷을 목적지까지 가장 빠른 길로 전송하기 위한 계층 (단위 :Packet) (ex. Router)&lt;/li&gt;
  &lt;li&gt;2 계층(데이터링크 계층) : 데이터의 물리적인 전송과 에러 검출, 흐름 제어를 담당하는 계층 (단위 :frame) (ex. 이더넷)&lt;/li&gt;
  &lt;li&gt;1 계층(물리 계층) : 데이터를 전기 신호로 바꾸어주는 계층 (단위 :bit) (장비: 케이블,리피터,허브)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;8-세션-기반-인증과-토큰-기반-인증의-차이에-대해-얘기해-주세요&quot;&gt;8. &lt;u&gt;세션 기반 인증&lt;/u&gt;과 &lt;u&gt;토큰 기반 인증&lt;/u&gt;의 차이에 대해 얘기해 주세요.&lt;/h4&gt;

&lt;p&gt;세션 기반 인증은 클라이언트로부터 요청을 받으면 클라이언트의 상태 정보를 저장하므로 Stateful한 구조를 가지고, 토큰 기반 인증은 상태 정보를 서버에 저장하지 않으므로 Stateless한 구조를 가집니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Stateful이란&lt;/strong&gt; server side에 client와 server의 동작, 상태정보를 저장하는 프로토콜이며 세션 상태에 기반하여 server의 응답이 달라집니다. 즉, &lt;strong&gt;&lt;em&gt;Stateful은 세션이 종료될 때까지 클라이언트의 세션 정보를 저장하는 네트워크 프로토콜&lt;/em&gt;&lt;/strong&gt;입니다. &lt;strong&gt;Stateless이란&lt;/strong&gt; server side에 client와 server의 동작, 상태정보를 저장하지 않는 프로토콜이며 server의 응답이 client와의 세션 상태와 독립적입니다. 즉 &lt;strong&gt;&lt;em&gt;Stateless는 서버가 클라이언트의 세션 상태 및 세션 정보를 저장하지 않는 네트워크 프로토콜&lt;/em&gt;&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;8-1-그렇다면-stateful한-세션-기반의-인증-방식을-사용하게-된다면-어떠한-단점이-있을까요&quot;&gt;8-1. 그렇다면 Stateful한 세션 기반의 인증 방식을 사용하게 된다면 어떠한 단점이 있을까요?&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;서버에 세션을 저장하기 때문에 사용자가 증가하면 서버에 과부하를 줄 수 있어 확장성이 낮습니다.&lt;/li&gt;
  &lt;li&gt;해커가 훔친 쿠키를 이용해 요청을 보내면 서버는 올바른 사용자가 보낸 요청인지 알 수 없습니다.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;8-2-jwtjson-web-token에-대해-설명해-주세요&quot;&gt;8-2. JWT(Json Web Token)에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;JWT란 JSON 포맷을 이용해 사용자에 대한 속성을 저장하는 Claim 기반의 웹 토큰이며, 토큰 자체를 정보로 사용하는 Self-Contained(자가수용적-JWT는 필요한 모든 정보를 자체적으로 가지고 있음) 방식으로 정보를 안전하게 전달합니다. JWT는 각 파트를 .으로 구분하여 헤더(Header).내용(Payload).서명(Signature) 형식으로 구성됩니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Clame이란&lt;/strong&gt; 사용자에 대한 프로퍼티나 속성을 뜻합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;9-restful에-대해-설명해-주세요&quot;&gt;9. RESTful에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;우선 REST란, HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)을 명시하고, HTTP Method(POST, GET, PUT, DELETE)를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것을 의미합니다. REST 기반으로 서비스 API를 구현한 것을 REST API라고 하며, 이러한 ‘REST API’를 제공하는 웹 서비스를 ‘RESTful’하다고 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;9-1-그렇다면-restful하지-못한-경우는-어떤-것인가요&quot;&gt;9-1. 그렇다면, RESTful하지 못한 경우는 어떤 것인가요?&lt;/h4&gt;

&lt;p&gt;CRUD 기능을 모두 POST로만 처리하는 API같은 경우 또는 route에 resource, id 외의 정보가 들어가는 경우 등이 있습니다.&lt;/p&gt;

&lt;p&gt;REST는 조금더 깊게 공부하시기를 추천드립니다. 명확한 표준이 존재하지 않는다는 점 또한 RESTful을 완전히 만족하는 API를 만들기는 생각보다 까다롭습니다. 자세한 공부를 원하신다면 🌎&lt;a href=&quot;https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html&quot;&gt;REST란? REST API란? RESTful이란?&lt;/a&gt;의 포스트를 확인해주세요.&amp;lt;/font&amp;gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-개발-면접-질문---운영체제&quot;&gt;🔎 개발 면접 질문 - 운영체제&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1-프로세스와-스레드의-차이를-설명해-주세요&quot;&gt;1. &lt;u&gt;프로세스&lt;/u&gt;와 &lt;u&gt;스레드&lt;/u&gt;의 차이를 설명해 주세요.&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;프로세스는 실행중인 프로그램을 의미합니다. 완벽히 독립적이기 때문에 메모리 영역(Code, Data, Heap, Stack)을 다른 프로세스와 공유하지 않습니다. 프로세스는 최소 1개의 쓰레드를 가지고 있습니다.&lt;/li&gt;
  &lt;li&gt;스레드는 실행 제어만 분리한 것을 의미합니다. 프로세스 내에서 Stack만 따로 할당 받고, 그 이외의 메모리 영역(Code, Data, Heap)영역을 공유하기 때문에 다른 쓰레드의 실행 결과를 즉시 확인할 수 있습니다. 쓰레드는 프로세스 내에 존재하며 프로세스가 할당받은 자원을 이용하여 실행됩니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2-멀티-프로세스와-멀티-스레드의-특징에-대해-설명해-주세요&quot;&gt;2. &lt;u&gt;멀티 프로세스&lt;/u&gt;와 &lt;u&gt;멀티 스레드&lt;/u&gt;의 특징에 대해 설명해 주세요.&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;멀티 프로세스는 하나의 프로세스가 죽어도 다른 프로세스에 영향을 끼치지 않고 계속 실행된다는 장점이 있지만 멀티 스레드보다 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 있습니다.&lt;/li&gt;
  &lt;li&gt;멀티 스레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만 하나의 스레드에 문제가 생기면 전체 쓰레드가 영향을 받으며 동기화 문제도 있다는 단점이 있습니다. 또한, 다수의 쓰레드가 공유 데이터에 동시에 접근하는 경우에 상호배제 또는 동기화 기법을 통해 동시성 문제 또는 교착 상태가 발생하지 않도록 주의해야 합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-멀티-스레드-프로그래밍에-대해-설명해-주세요&quot;&gt;3. 멀티 스레드 프로그래밍에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;멀티 스레드 프로그래밍은 하나의 프로세스에서 여러개의 스레드를 만들어 자원의 생성과 관리의 중복을 최소화하는 것을 멀티 스레드 프로그래밍이라고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;장점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;멀티 프로세스에 비해 메모리 자원소모가 줄어듭니다.&lt;/li&gt;
  &lt;li&gt;힙 영역을 통해서 스레드간 통신이 가능해서 프로세스간 통신보다 간단합니다.&lt;/li&gt;
  &lt;li&gt;스레드의 컨텍스트 스위칭은 프로세스의 컨텍스트 스위칭보다 빠릅니다.
&lt;strong&gt;단점&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;힙 영역에 있는 자원을 사용할 때는 동기화를 해야합니다.&lt;/li&gt;
  &lt;li&gt;동기화를 위해서 락을 과도하게 사용하면 성능이 저하될 수 있습니다.&lt;/li&gt;
  &lt;li&gt;하나의 스레드가 비정상적으로 동작하면 다른 스레드도 종료될 수 있습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-1-멀티-프로세스-or-멀티-스레드-프로그래밍을-해본-경험이-있나요&quot;&gt;3-1. &lt;u&gt;멀티 프로세스&lt;/u&gt; or &lt;u&gt;멀티 스레드&lt;/u&gt; 프로그래밍을 해본 경험이 있나요?&lt;/h4&gt;

&lt;p&gt;저는 🌎&lt;a href=&quot;https://liampoet.github.io/Python-GIL/&quot;&gt;Python GIL, Global interpreter Lock&lt;/a&gt;을 공부하기 위해 멀티 스레딩을 경험해 본 적이 있습니다. 이 문제는 지원자분이 멀티 프로세스 or 멀티 스레드를 구현해본 경험을 이야기 하시면 될 것 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-컨텍스트-스위칭context-switching에-대해-설명해-주세요&quot;&gt;4. 컨텍스트 스위칭(Context Switching)에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;컨텍스트 스위칭(Context Switching)은 한 Task가 끝날 때까지 기다리는 것이 아니라 여러 작업을 번갈아가며 실행해서 동시에 처리될 수 있도록 하는 방법입니다. 인터럽트가 발생하면 현재 프로세스의 상태를 PCB에 저장하고 새로운 프로세스의 상태를 레지스터에 저장하는 방식으로 동작합니다. 이 때, CPU는 아무런 일을 하지 않으므로 잦은 컨텍스트 스위칭은 성능저하를 일으킬 수 있습니다. 스레드와 프로세스의 동작방식이 약간 상이한데, 스레드는 캐시메모리나 PCB에 저장해야하는 내용이 적고, 비워야 하는 내용도 적기때문에 상대적으로 더 빠른 컨텍스트 스위칭이 일어날 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;5-동기와-비동기의-차이에-대해-설명해-주세요&quot;&gt;5. &lt;u&gt;동기&lt;/u&gt;와 &lt;u&gt;비동기&lt;/u&gt;의 차이에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;동기는 순차적, 직렬적으로 테스크를 수행하고, 비동기는 병렬적으로 테스크를 수행합니다. 예를 들어, 서버에서 데이터를 가져와서 화면에 표시하는 작업을 수행할 때, 동기는 서버에 데이터를 요청하고 데이터가 응답될 때까지 이후 테스크들은 블로킹(Blocking, 작업 중단)됩니다. 비동기는 서버에 데이터를 요청한 이후 서버로부터 데이터가 응답될 때까지 대기하지 않고(Non-Blocking) 즉시 다음 테스크를 계속해 수행합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;6-데드락deadlock이-무엇인가요&quot;&gt;6. 데드락(DeadLock)이 무엇인가요?&lt;/h4&gt;

&lt;p&gt;데드락(DeadLock) 또는 교착상태란 한정된 자원을 여러 프로세스가 사용하고자 할 때 발생하는 상황으로, 프로레스가 자원을 얻기 위해 영구적으로 기다리는 상태입니다. 예를 들어 다음과 같은 상황에서 데드락이 발생할 수 있습니다. 자원 A를 가진 프로세스 P1과 자원 B를 가진 프로세스 P2가 있을 때, P1은 B를 필요로 하고 P2는 A를 필요로 한다면 두 프로세스 P1, P2는 서로 자원을 얻기위해 무한정 기다리게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/interview/deadlock.png&quot; alt=&quot;Deadlock 예시&quot; /&gt;&lt;em&gt;이미지 4. DeadLock&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;7-뮤텍스mutex와-세마포어semaphore의-차이에-대해-설명해-주세요&quot;&gt;7. &lt;u&gt;뮤텍스(Mutex)&lt;/u&gt;와 &lt;u&gt;세마포어(Semaphore)&lt;/u&gt;의 차이에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;세마포어는 여러개의 프로세스가 접근 가능한 공유자원을 관리하는 방식이고, 뮤텍스가 될 수 있지만, 뮤텍스는 한 번에 한 개의 프로세스만 접근 가능하도록 관리하는 방식입니다. 따라서 뮤텍스는 세마포어가 될 수 없습니다. 또, 세마포어는 다른 프로세스가 세마포어를 해제할 수 있지만, 뮤텍스는 락을 획득한 프로세스만 락을 반환할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;8-가상-메모리와-페이지-폴트에-대해-설명해-주세요&quot;&gt;8. &lt;u&gt;가상 메모리&lt;/u&gt;와 &lt;u&gt;페이지 폴트&lt;/u&gt;에 대해 설명해 주세요.&lt;/h4&gt;

&lt;p&gt;가상메모리는 RAM의 부족한 용량을 보완하기 위해, 각 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 할당하는 방식입니다. OS는 프로세스들의 내용(페이지) 중에서 덜 중요한 것들을 하드디스크에 옮겨 놓고, 관련 정보를 페이지 테이블에 기록합니다. CPU는 프로세스를 실행하면서 페이지 테이블을 통해 페이지를 조회하는데, 실제메모리에 원하는 페이지가 없는 상황이 발생할 수 있습니다. 이것을 페이지 폴트라고 하는데 프로세스가 동작하면서 실제메모리에 필요한 데이터(페이지)가 없으면 가상메모리를 통해서 해당 데이터를 가져오게 됩니다. 가상메모리는 하드디스크에 저장되어 있기 때문에, 페이지폴트가 발생하면 I/O에 의한 속도의 저하가 발생합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;9-페이지-교체-알고리즘에-대해-설명해주세요&quot;&gt;9. 페이지 교체 알고리즘에 대해 설명해주세요.&lt;/h4&gt;

&lt;p&gt;페이지를 교체하는 이유는 가상메모리를 통해 조회한 페이지는 다시 사용될 가능성이 높기 때문입니다. 페이지 교체를 위해서는 실제메모리에 존재하는 페이지를 가상메모리로 저장한 후에, 가상메모리에서 조회한 페이지를 실제메모리로 로드해야 됩니다. 이 때 사용되어지는 알고리즘을 페이지 교체 알고리즘이라고 합니다. 아래는 대표적인 페이지 교체 알고리즘 입니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FIFO(First In First Out) : FIFO 알고리즘은 &lt;strong&gt;메모리에 올라온 지 가장 오래된 페이지를 교체&lt;/strong&gt;합니다. 간단하고, 초기화 코드에 대해 적절한 방법이며, 페이지가 올라온 순서를 큐에 저장합니다.&lt;/li&gt;
  &lt;li&gt;LRU(Least Recently Used) : LRU 알고리즘은 &lt;strong&gt;실제메모리의 페이지들 중에서 가장 오랫동안 사용되지 않은 페이지를 선택하는 방식&lt;/strong&gt;입니다.&lt;/li&gt;
  &lt;li&gt;추가로 참조 횟수가 가장 작은 페이지를 교체하는 알고리즘인 LFU(Least Frequently Used)와 참조 횟수가 가장 많은 페이지를 교체하는 알고리즘인 MFU(Most Frequently Used)가 있는데 구현에 상당한 비용이 들고, 최적 페이지 교체 정책을 제대로 LRU만큼 유사하게 구현해내지 못하기 때문에 실제로는 잘 사용 되어지지 않습니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;끝맺음&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;공부를 하면서 질문에 괜찮은 내용이 있으면 요약하면서 계속 추가하고 있습니다. 또한, 기본적인 이론에 대해 다시 공부를 하려고 정리한 내용이기 때문에 잘못된 부분들이 있을 수도 있습니다. 잘못된 정보가 보이거나, 부족한 내용, 추가되면 좋을 것 같은 내용이 있다면 댓글에 적어주시면 감사하겠습니다!😊&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[참고자료]&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://velopert.com/2389&quot;&gt;JSON Web Token 이 뭘까?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://smjeon.dev/etc/interview-question/&quot;&gt;https://smjeon.dev/etc/interview-question/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://velog.io/@minsgy/백엔드-개발자-면접학습내용&quot;&gt;minsgy-백엔드 개발자 [면접/학습내용]&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 22 Jul 2022 15:28:55 +0900</pubDate>
        <link>http://localhost:4000/interview1/</link>
        <guid isPermaLink="true">http://localhost:4000/interview1/</guid>
        
        
        <category>Interview</category>
        
      </item>
    
      <item>
        <title>(문제해결)You do not have the SUPER privilege and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)</title>
        <description>&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-intro&quot;&gt;💡 Intro&lt;/h2&gt;

&lt;p&gt;MySQL을 사용하는중에 특정 테이블에 트리거를 생성했는데, &lt;code class=&quot;highlighter-rouge&quot;&gt;You do not have the SUPER privilege and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)&lt;/code&gt;라는 에러가 발생했습니다. 구글에서 정보를 찾아보니 계정에 권한이 없으니 &lt;strong&gt;log_bin_trust_function_creators variable&lt;/strong&gt;의 설정을 변경해야 한다고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-rds-log_bin_trust_function_creators&quot;&gt;🔎 RDS log_bin_trust_function_creators&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;log_bin_trust_function_creators&lt;/strong&gt; 옵션은 MySQL이 함수를 수정 및 생성에 대한 제약을 강제할 수 있는 기능입니다.
해당 옵션의 default는 0(OFF)이며, OFF상태의 경우 권한이 있더라도 trigger를 생성할 수 없고, function을 생성할 수 없습니다. SUPER 권한이 있는 사용자만이 함수를 생성 및 변경할 수 있다고 합니다. 또한 &lt;strong&gt;log_bin_trust_function_creators&lt;/strong&gt; 옵션을 1(ON)로 설정한 경우에는 함수 생성에 제약을 받지 않습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-aws-rds-파라미터-그룹-변경하기&quot;&gt;📚 AWS RDS 파라미터 그룹 변경하기&lt;/h2&gt;

&lt;h3 id=&quot;-1-log_bin_trust_function_creators-옵션-변경하기&quot;&gt;📕 1. log_bin_trust_function_creators 옵션 변경하기&lt;/h3&gt;

&lt;p&gt;AWS RDS의 파라미터 그룹으로 들어가 줍니다. 그리고 변경할 파라미터 그룹의 이름을 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mysql-error/ERROR1227-1.png&quot; alt=&quot;ERROR1227-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그리고 파리미터 편집으로  &lt;strong&gt;log_bin_trust_function_creators&lt;/strong&gt;에 0(OFF)으로 되어져있는 옵션의 값을 1로 변경해줍니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mysql-error/ERROR1227-2.png&quot; alt=&quot;ERROR1227-2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;-2-데이터베이스-파라미터-그룹-변경&quot;&gt;📘 2. 데이터베이스 파라미터 그룹 변경&lt;/h3&gt;

&lt;p&gt;AWS RDS의 데이터베이스에 들어갑니다. 그리고 우측의 수정을 클릭합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mysql-error/ERROR1227-3.png&quot; alt=&quot;ERROR1227-3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;추가 구성의 데이터베이스 옵션으로 가서 &lt;strong&gt;DB파라미터 그룹&lt;/strong&gt;을 default에서 위에서 설정한 그룹으로 변경합니다. 그리고 맨 밑의 &lt;strong&gt;DB인스턴스 수정&lt;/strong&gt;을 클릭하면 수정됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mysql-error/ERROR1227-4.png&quot; alt=&quot;ERROR1227-4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[참고자료]&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/premiumsupport/knowledge-center/rds-mysql-functions/&quot;&gt;https://aws.amazon.com/ko/premiumsupport/knowledge-center/rds-mysql-functions/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 01 Jul 2022 16:42:29 +0900</pubDate>
        <link>http://localhost:4000/mysql-error2/</link>
        <guid isPermaLink="true">http://localhost:4000/mysql-error2/</guid>
        
        
        <category>MySQL</category>
        
        <category>AWS RDS</category>
        
      </item>
    
      <item>
        <title>Python GIL, Global interpreter Lock</title>
        <description>&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-intro&quot;&gt;💡 Intro&lt;/h2&gt;

&lt;p&gt;오늘은 Python의 가장 큰 특징중 하나인 GIL(Global interpreter Lock)에 대해 알아보려고 합니다. Python을 사용하는 개발자라면 누구나 다 한번쯤은 들어봤을 것이고, 저 또한 GIL에 대해 공부해 본적이 있지만 다시 한번 정리해 보려고 합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-python-인터프리터란&quot;&gt;🔎 Python 인터프리터란?&lt;/h2&gt;

&lt;p&gt;우선 GIL이란 Global Interpreter Lock의 약자로 파이썬 인터프리터가 한 쓰레드만이 하나의 바이트코드를 실행 시킬 수 있도록 해주는 Lock입니다. 즉, Python 인터프리터는 한 번에 한 쓰레드만 실행될 수 있다는 것을 의미합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 파이썬 인터프리터란 무엇일까요? Python 인터프리터란, Python으로 작성된 코드를 한 줄씩 읽으면서 실행하는 프로그램을 뜻 합니다. Python 인터프리터에 대한 자세한 내용은 &lt;a href=&quot;https://soooprmx.com/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9D%80-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0%EC%96%B8%EC%96%B4%EC%9E%85%EB%8B%88%EA%B9%8C/&quot;&gt;파이썬은 인터프리터언어입니까?&lt;/a&gt; 블로그에서 조금 더 심도깊게 생각해보실 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-gilglobal-interpreter-lock&quot;&gt;🔎 GIL(Global Interpreter Lock)&lt;/h2&gt;

&lt;p&gt;GIL (Global Interpreter Lock)을 🌎&lt;a href=&quot;https://wiki.python.org/moin/GlobalInterpreterLock&quot;&gt;Python 위키&lt;/a&gt;에서는 다음과 같이 정의하고 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In CPython, the &lt;strong&gt;global interpreter lock&lt;/strong&gt;, or &lt;strong&gt;GIL&lt;/strong&gt;, is a mutex that protects access to Python objects, preventing multiple threads from executing Python bytecodes at once. The GIL prevents race conditions and ensures thread safety. A nice explanation of 🌎&lt;a href=&quot;https://python.land/python-concurrency/the-python-gil&quot;&gt;how the Python GIL helps in these areas can be found here&lt;/a&gt;. In short, this mutex is necessary mainly because CPython’s memory management is not thread-safe.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;해석을 해보면, Python의 객체들에 대한 접근을 보호하는 일종의 Mutex로서 여러 개의 쓰레드가 파이썬 코드를 동시에 실행하지 못하도록 하는 것을 의미합니다. 즉, 한 프로세스 내에서 Python 인터프리터는 한 시점에 하나의 쓰레드에 의해서만 실행될 수 있습니다. 멀티 쓰레딩이 불가능하다는 것이 아니나, 원래 멀티 코어라면 멀티 쓰레딩 시에 여러 개의 쓰레드가 여러 코어 상에서 병렬실행될 수 있는데, Python에서는 그러한 병렬 실행이 불가능하다는 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;간단하게 설명을 해보자면, 3개의 쓰레드를 통해 작업을 한다고 가정했을 때 하나의 쓰레드에 모든 자원을 허락하고 그 후에는 Lock을 걸어 다른 스레드는 실행할 수 없게 막아버림으로써, 각각의 쓰레드는 GIL을 얻고 동작하지만 이 때 다른 쓰레드는 모두 동작을 멈추게 됩니다. 이를 그림으로 나타내면 다음과 같습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/gil/GIL1.png&quot; alt=&quot;GIL1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-그럼-gil이-왜-생긴걸까&quot;&gt;🔎 그럼 GIL이 왜 생긴걸까?&lt;/h2&gt;

&lt;p&gt;Python에서 모든 것은 객체(Object)입니다. 그리고 각 객체는 Reference Count를 저장하기 위한 필드를 가지고 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Reference Count란 그 객체를 가리키는 Reference가 몇 개 존재하는지를 나타내는 것으로, Python에서의 GC(Garbage Collection)는 이러한 Reference Count가 0이 되면 해당 객체를 메모리에서 삭제시키는 메커니즘으로 동작하고 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;따라서 파이썬의 모든 객체는 Reference count, 즉 해당 변수가 참조된 수를 저장하고 있습니다. 여기서 문제가 발생하게 되는데, 멀티 쓰레드인 경우 여러 쓰레드가 하나의 객체를 사용한다면 Reference count를 관리하기 위해서 모든 객체에 대한 lock이 필요할 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이러한 비효율을 막기 위해서 Python에서 GIL을 사용하게 되었습니다. 그 당시 GIL을 선택해야 했던 이유는 🌎&lt;a href=&quot;https://realpython.com/python-gil/&quot;&gt;What Is the Python Global Interpreter Lock (GIL)?&lt;/a&gt; 에서 찾을 수 있었습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Python has been around since the days when operating systems did not have a concept of threads. Python was designed to be easy-to-use in order to make development quicker and more and more developers started using it. A lot of extensions were being written for the existing C libraries whose features were needed in Python. To prevent inconsistent changes, these C extensions required a thread-safe memory management which the GIL provided. The GIL is simple to implement and was easily added to Python. It provides a performance increase to single-threaded programs as only one lock needs to be managed. C libraries that were not thread-safe became easier to integrate. And these C extensions became one of the reasons why Python was readily adopted by different communities. As you can see, the GIL was a pragmatic solution to a difficult problem that the CPython developers faced early on in Python’s life.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;-그렇다면-python-멀티쓰레딩은-무조건-느릴까&quot;&gt;📚 그렇다면 Python 멀티쓰레딩은 무조건 느릴까?&lt;/h2&gt;

&lt;p&gt;CPU 연산의 비중이 큰 작업을 할 때, Context Switching으로 인해 괜한 Cost만 잡아먹기 때문에 멀티 쓰레딩은 오히려 성능을 떨어뜨리게 됩니다. 하지만 I/O, Sleep 등의 외부 연산을 하느라 CPU가 아무것도 하지 않고 기다리기만 할 때는 다른 쓰레드로 Context Switching을 하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;그러한 이유로 CPU 연산의 비중이 적은 I/O, Sleep 등의 외부 연산 같이 비중이 큰 작업을 할 때는 멀티 쓰레딩이 굉장히 좋은 성능을 보여주게 됩니다. 즉, &lt;strong&gt;Python 멀티쓰레딩은 무조건 느리다라는 말은 맞는 말이 아닙니다.&lt;/strong&gt; 다음 예시를 통해 설명이 가능합니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-py highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;random&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;threading&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;


&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;working&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)])&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)])&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;# Single Thread
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;working&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;working&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;e_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'{e_time - s_time:.5f}'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;


&lt;span class=&quot;c1&quot;&gt;# Multi Thread
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;threads&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;threads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;threading&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;working&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;threads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threads&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;e_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'{e_time - s_time:.5f}'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;


&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;아래와 같이 확연한 차이를 볼 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;language-py highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
&lt;span class=&quot;n&quot;&gt;Single&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;10.77272&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Multi&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;7.17564&lt;/span&gt;


&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Single Thread는 &lt;code class=&quot;highlighter-rouge&quot;&gt;sleep&lt;/code&gt;으로 인해 &lt;em&gt;아무 것도 못하고 동작을 대기&lt;/em&gt;하게 되고, Multi Thread는 &lt;code class=&quot;highlighter-rouge&quot;&gt;sleep&lt;/code&gt;으로 멈춘 상태에서 다른 스레드로 &lt;em&gt;Context Switching하여 Single Thread의 효율을 개선&lt;/em&gt;하게 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;끝맺음
Python으로 작업하는 개발자의 입장으로써 지금까지는 GIL로 인한 불편한점은 느낄 수 없었습니다. 하지만 뜻하지 않은 계기로 오랜만에 다시 GIL(Global Interpreter Lock)을 공부하게 되었는데, GIL에 대한 역사와 Python의 GC에 대해 충분히 이해할 수 있었던것 만으로도 매우 의미있는 시간이었다고 생각합니다.😊&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[참고자료]&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://soooprmx.com/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9D%80-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0%EC%96%B8%EC%96%B4%EC%9E%85%EB%8B%88%EA%B9%8C/&quot;&gt;파이썬은 인터프리터언어입니까?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ciokorea.com/news/210764&quot;&gt;파이썬이 마침내 ‘GIL’을 제거할 수 있을까?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://soooprmx.com/%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9D%80-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0%EC%96%B8%EC%96%B4%EC%9E%85%EB%8B%88%EA%B9%8C/&quot;&gt;Python 위키&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://dgkim5360.tistory.com/entry/understanding-the-global-interpreter-lock-of-cpython&quot;&gt;왜 Python에는 GIL이 있는가&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.dabeaz.com/python/UnderstandingGIL.pdf&quot;&gt;Davie Beazley의 Understanding the Python GIL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 16 Jun 2022 14:30:28 +0900</pubDate>
        <link>http://localhost:4000/python-gil/</link>
        <guid isPermaLink="true">http://localhost:4000/python-gil/</guid>
        
        
        <category>Python</category>
        
      </item>
    
  </channel>
</rss>
